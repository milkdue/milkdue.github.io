<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>typescript基础 | 可以清心</title><meta name="keywords" content="typescript"><meta name="author" content="可以清心"><meta name="copyright" content="可以清心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="tensorflow"><meta property="og:type" content="article"><meta property="og:title" content="typescript基础"><meta property="og:url" content="https://blog.keyiqingxin.cn/9f47fabe/index.html"><meta property="og:site_name" content="可以清心"><meta property="og:description" content="tensorflow"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.keyiqingxin.cn/cover/552320.jpg"><meta property="article:published_time" content="2023-06-29T16:08:01.000Z"><meta property="article:modified_time" content="2025-02-11T08:23:27.167Z"><meta property="article:author" content="可以清心"><meta property="article:tag" content="typescript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.keyiqingxin.cn/cover/552320.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.keyiqingxin.cn/9f47fabe/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="baidu_site_verification" content="code-vvu3hMVkFQ"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#212121"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/favicon-16x16.png"><link rel="mask-icon" href="/img/siteicon/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/index.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/fontawesome/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/snackbar/snackbar.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?1668a6d436fb091fab3554501beeff3a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:1,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:30,position:"top",messagePrev:"读者请注意，本文章更新于",messageNext:"天前，文中某些信息可能已经过时，如有任何问题，请在文章末尾评论处留言！"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"吾辈宣布你的剪贴板已经被我占领啦！",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#2d3035",position:"top-center"},source:{jQuery:"https://cdn.keyiqingxin.cn/jquery/jquery.min.js",justifiedGallery:{js:"https://cdn.keyiqingxin.cn/justifiedGallery/js/jquery.justifiedGallery.min.js",css:"https://cdn.keyiqingxin.cn/justifiedGallery/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.keyiqingxin.cn/fancybox/jquery.fancybox.min.js",css:"https://cdn.keyiqingxin.cn/fancybox/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-02-11 16:23:27"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px")})(window)</script><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/my.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/twikoo_beautify.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/fixed_comment.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/comment_barrage.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/tianli_gpt/tianli-gpt.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/bdhistory/css/main.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/zfswiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/zfswiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/runtime/runtime.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/animate/animate.min.css" media="print" onload='this.media="screen"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/tag_plugin/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.keyiqingxin.cn/carousel/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/tag_plugin/mindmap.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg" style="background:url(https://cdn.keyiqingxin.cn/cover/552320.jpg);background-attachment:local;background-position:center;background-size:cover;background-repeat:no-repeat"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.keyiqingxin.cn/avatar/avatar.jpg" onerror='onerror=null,src="https://cdn.keyiqingxin.cn/avatar/avatar1.jpg"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分類</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>光影</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i> <span>清單</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音樂</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>電影</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://picx.xpoet.cn/"><i class="fa-fw fa fa-bed"></i> <span>图床</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/chart/"><i class="fa-fw fa fa-map"></i> <span>統計</span></a></div><div class="menus_item"><a class="site-page" href="/sponsor/"><i class="fa-fw fa fa-gift"></i> <span>贊助</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友鏈</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.keyiqingxin.cn/cover/552320.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">可以清心</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分類</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>光影</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i> <span>清單</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音樂</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>電影</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://picx.xpoet.cn/"><i class="fa-fw fa fa-bed"></i> <span>图床</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/chart/"><i class="fa-fw fa fa-map"></i> <span>統計</span></a></div><div class="menus_item"><a class="site-page" href="/sponsor/"><i class="fa-fw fa fa-gift"></i> <span>贊助</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友鏈</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">typescript基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-29T16:08:01.000Z" title="发表于 2023-06-30 00:08:01">2023-06-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-11T08:23:27.167Z" title="更新于 2025-02-11 16:23:27">2025-02-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0-%E6%95%99%E7%A8%8B/">学习&amp;教程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>98分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="typescript基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="TypeScript-入门"><code>TypeScript</code> 入门</h2><h3 id="TSC-编译器"><code>TSC</code> 编译器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><h3 id="发出错误">发出错误</h3><ol><li><code>--noEmitOnError</code> 不允许发生错误，一旦发生错误将不会生成 <code>js</code> 文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --noEmitOnError hello.ts</span><br></pre></td></tr></table></figure><h3 id="显式类型">显式类型</h3><ol><li>明确指定参数或变量的类型</li><li>但是我们不总是需要编写明确的类型，在大多数情况下，<code>TypeScript</code> 会自动推断代码中的类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: <span class="built_in">string</span>, data: <span class="built_in">Date</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;suxi&quot;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure><h3 id="擦拭类型">擦拭类型</h3><ol><li><code>tsc</code> 编译后的 <code>js</code> 将类型擦除掉</li><li>类型注释永远不会改变程序的运行时行为</li></ol><h3 id="降级编译">降级编译</h3><ol><li><code>tsc</code> 指定编译生成 <code>js</code> 的版本</li><li><code>tsc --target es2015 hello.ts</code></li></ol><h3 id="严格模式">严格模式</h3><ol><li><code>tsc --strict true hello.ts</code> 开启严格模式</li><li><code>tsc --strict true --noImplictAny true</code> 开启严格模式，并且当类型隐式推断为 <code>any</code> 时发出错误</li><li><code>tsc --target es2015 --strictNullChecks true</code> <code>null</code> 和 <code>undefined</code> 可以分配给任意类型，这可能会导致空异常，开启 <code>strictNullChecks</code> 可以防止出现空异常</li></ol><h2 id="常用类型">常用类型</h2><h3 id="typescript"><code>typescript</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2016&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./src&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基元类型-number-string-boolean">基元类型 <code>number</code> <code>string</code> <code>boolean</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> s: <span class="built_in">string</span> = <span class="string">&quot;abs&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="数组">数组</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> strs: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>];</span><br></pre></td></tr></table></figure><h3 id="any"><code>any</code></h3><ol><li>当不希望某个特定值导致类型检查错误时，可以使用 <code>any</code></li><li>当一个值的类型是 <code>any</code> 时，可以访问它的任何属性，将它分配给任何类型的值</li><li>但在运行环境下执行代码可能是错误的</li><li>当我们不指定类型时，并且 <code>typescript</code> 无法从上下文推断它时，编译器通常会默认为 <code>any</code>，但是通常情况下，我们需要避免这种情况，因为 <code>any</code> 没有进行类型检查，使用 <code>noImplicitAny</code> 将任何隐式标记 <code>any</code> 为错误</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">any</span> = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br><span class="line">obj.bar = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> n: <span class="built_in">number</span> = obj;</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="变量上的类型注释">变量上的类型注释</h3><ol><li>可以选择添加类型注释来显式指定变量的类型</li><li>但是这不是必须的，因为 <code>typescript</code> 会尝试自动推断代码中的类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: <span class="built_in">string</span> = <span class="string">&quot;suxi&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">&quot;peiqi&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><h4 id="参数类型注释">参数类型注释</h4><ol><li>即便没有参数类型注释，仍然会检查参数的数量</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="number">42</span>); <span class="comment">// error</span></span><br><span class="line">greet(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;456&quot;</span>); <span class="comment">// error</span></span><br><span class="line">greet(<span class="string">&quot;42&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="返回类型注释">返回类型注释</h4><ol><li>通常不需要返回类型，因为 <code>typescript</code> 会推断出返回类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名函数">匿名函数</h4><ol><li>匿名函数与函数声明有所不同，当一个函数出现在 <code>typescript</code> 可以确定它将如何被调用的地方时，该函数的参数会自动指定类型</li><li>上下文推断类型，函数发生在其中的上下文通知它应该具有什么类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>];</span><br><span class="line"><span class="comment">// 自动推断 name 为 string</span></span><br><span class="line">names.forEach(<span class="function"><span class="params">name</span> =&gt;</span> <span class="built_in">console</span>.log(name.toUpperCase()));</span><br></pre></td></tr></table></figure><h3 id="对象类型">对象类型</h3><ol><li>下面是一个对象类型的例子</li><li><code>x</code> 和 <code>y</code> 是对象的属性，它们的类型为 <code>number</code></li><li>可以使用 <code>,</code> 或 <code>;</code> 分隔属性，最后一个分割符是可选的</li><li>每个属性的类型部分也是可选的，如果不指定类型，则将假定为 <code>any</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: &#123; <span class="attr">x</span>: <span class="built_in">number</span>; y: <span class="built_in">number</span>; &#125; = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可选属性">可选属性</h4><ol><li>对象类型还可以指定其部分或全部属性是可选的</li><li>在属性后添加 <code>?</code> 表示其可选属性</li><li>当使用可选属性时，首先要判断是否存在</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: &#123; <span class="attr">x</span>: number; y: number; z?: number &#125; = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (point.z !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;三维坐标&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;二维坐标&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span>,</span><br><span class="line">    z: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="联合类型">联合类型</h3><p><code>typescript</code> 允许使用多种运算符从现有类型中构建新类型</p><ol><li><p>定义联合类型</p><ul><li>联合类型是由多个其他类型组成的类型，表示可以是这些类型中的任何一种类型</li><li>这些类型中的每一种类型称为联合类型的成员</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id);</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="number">123</span>);</span><br><span class="line">print(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用联合类型</p><ul><li>提供联合类型很容易，但是使用时，如果联合的每个成员都有效，<code>ts</code> 将只允许使用联合做一些事情，例如，如果 <code>string | number</code> 联合类型，不能只使用一种类型的操作</li><li>而是使用代码缩小联合，就像没有类型注释的 <code>js</code> 一样，当 <code>ts</code> 可以根据代码结构为值推断为具体的类型时，就会发生缩小</li><li>当然有时对于一个 <code>union</code> 所有成员都有一些共同点，例如，数组和字符串都有一个 <code>slice</code> 方法那么使用该属性就可以不会缩小范围</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id.toUpperCase())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// id 为 string</span></span><br><span class="line">        <span class="built_in">console</span>.log(id.toUpperCase())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// id 为 number</span></span><br><span class="line">        <span class="built_in">console</span>.log(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstThree</span>(<span class="params">x: <span class="built_in">number</span>[] | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.slice(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="类型别名">类型别名</h3><ol><li>如果我们想要多次使用一个类型，恰好这个类型的定义又很复杂，我们可以使用类型别名来声明类型，以便于多次引用它</li><li>当然类型别名只是别名，不能使用类型别名来创建相同类型的不同版本</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    z?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point: Point = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ID = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><h3 id="接口">接口</h3><ol><li>接口声明是另一种方式来命名对象类型</li><li><code>ts</code> 只关注类型的结构和功能</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    z?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point: Point = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span>,</span><br><span class="line">    z: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口和类型别名之间的差异">接口和类型别名之间的差异</h4><ol><li>类型别名和接口非常相似，在多数情况下可以自由的选择它们，几乎所有功能都在 <code>interface</code> 中可用 <code>type</code> 关键区别在于扩展新类型的方式不同</li><li>类型别名可能不参与声明合并，但接口可以</li><li>接口只能用于声明对象的形状，不能重命名基元</li><li>接口名称将始终以其原始形式出现在错误消息中，但仅当它们按名称使用时</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展接口</span></span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bear <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    honey: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bear: Bear = &#123;</span><br><span class="line">    name: <span class="string">&quot;winnie&quot;</span>,</span><br><span class="line">    honey: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bear.name;</span><br><span class="line">bear.honey;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过交叉点扩展类型</span></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bear = Animal &amp; &#123;</span><br><span class="line">    honey: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bear: Bear = &#123;</span><br><span class="line">    name: <span class="string">&quot;winnie&quot;</span>,</span><br><span class="line">    honey: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bear.name;</span><br><span class="line">bear.honey;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向现有类型添加新字段</span></span><br><span class="line"><span class="keyword">interface</span> MyWindow &#123;</span><br><span class="line">    title: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> MyWindow &#123;</span><br><span class="line">    content: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> w: MyWindow = &#123;</span><br><span class="line">    title: <span class="string">&quot;hello ts&quot;</span>,</span><br><span class="line">    content: <span class="string">&quot;ts is pop&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型创建后不可更改</span></span><br><span class="line"><span class="keyword">type</span> MyWindow = &#123;</span><br><span class="line">    title: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyWindow = &#123;</span><br><span class="line">    content: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型断言">类型断言</h3><ol><li><p>有时，我们会获得有关 <code>TS</code> 不知道的值类型的信息，例如 <code>document.getElementById</code> ， <code>TS</code> 只知道它将返回某种类型的 <code>HTMLElement</code> 但我们自己知道它将始终返回 <code>HTMLCanvasElement</code> 类型与穷尽性检查，这种情况下，我们需要类型断言来指定更加具体的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>) <span class="keyword">as</span> HTMLCanvasElement;</span><br></pre></td></tr></table></figure></li><li><p>和类型注释一样，类型断言不会影响代码的运行行为并由编译器删除断言，当然也可以使用 <code>&lt;&gt;</code> 进行断言，它们是等效的，但是需要注意这种方式不可以用在 <code>tsx</code> 中</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = &lt;HTMLCanvasElement&gt;<span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>TS</code> 只允许断言转换为更具体或不太具体的类型版本，此规则可防止不可能的断言</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可能的断言 因为这两种类型没有充分重叠</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="string">&quot;hello&quot;</span> <span class="keyword">as</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 需要先断言为 unknown 或 any 类型 在断言为 number 类型</span></span><br><span class="line"><span class="keyword">const</span> (x = <span class="string">&quot;hello&quot;</span> <span class="keyword">as</span> unknown) <span class="keyword">as</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="文字类型">文字类型</h3><ol><li><p>除了一般类型 <code>string</code> <code>number</code>，我们还可以在类型位置引用特定的字符串和数字</p></li><li><p>一种方法是考虑 <code>js</code> 如何以不同的方式声明变量</p><ul><li><code>var</code> <code>let</code> 两者都允许更改变量中保存的内容</li><li><code>const</code> 不允许，这反映在 <code>ts</code> 如何为文字创建类型上</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testString = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">testString = <span class="string">&quot;123&quot;</span>; <span class="comment">// 可以任意更改 相当于 testString的类型是 string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> constantString = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">// 已经不能在更改了，它只能表示一个可能的字符串，所有实际上 constantString 的类型是 &quot;hello world&quot; 这就是文字类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但就其本身而言，文字类型并不是很有价值</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="string">&quot;hello&quot;</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">x = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&quot;xxxx&quot;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li><li><p>拥有一个只能有一个值的变量并没有多大用处，但是通过将文字组合成联合类型，可以用来表达一个更有用的概念 — 例如只接受一组特定的值</p></li><li><p>当然文字类型也可以和非文字类型结合使用</p></li><li><p>还有一种文字类型：布尔文字，只有两种布尔文字类型，它们是类型 <code>true</code> 和 <code>false</code> 注意，此时他们是文字类型，不是值。那么基元 <code>boolean</code> 也本身是联合类型 <code>true</code> | <code>false</code> 的别名，可以这样理解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printText</span>(<span class="params">s: <span class="built_in">string</span>, align: <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s, align);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printText(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;left&quot;</span>);</span><br><span class="line">printText(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;right&quot;</span>);</span><br><span class="line">printText(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;center&quot;</span>); <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): -1 | 0 | 1 </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a === b ? <span class="number">0</span> : a &gt; b ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configure</span>(<span class="params">x: Options | <span class="string">&quot;auto&quot;</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">configure(&#123; <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br><span class="line">configure(<span class="string">&quot;auto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> auto = <span class="string">&quot;auto&quot;</span>; <span class="comment">// 注意 这是 string 隐式 它不是文字类型 而是基元 string 不能直接 configure(auto) 这是错误的</span></span><br><span class="line"><span class="comment">// configure(auto);</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="文字推理">文字推理</h4><ol><li><p>当我们使用对象初始化变量时，<code>TS</code> 假定该对象的属性稍后可能会更改值</p><ul><li>所以 <code>const</code> 定义对象时，并不认为 <code>counter</code> 就是一个文字类型，而是认为它是一个基元 <code>number</code>，所以我们改变 <code>counter</code> 的值，<code>ts</code> 并不认为它是错误的</li><li>这也符合 <code>js</code> 中的行为</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;; <span class="comment">// 注意对象 const counter 属性可能改变</span></span><br><span class="line">obj.counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">obj.counter = <span class="string">&quot;number&quot;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li><li><p>上面的行为同样适用于字符串</p></li><li><p>可以使用 <code>as const</code> 将整个对象转换为类型文字，就是说，确保了对象的所有属性分配的都是文字类型，而不是一个更一般的 <code>string</code> <code>number</code> 等</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRequest</span>(<span class="params">url: <span class="built_in">string</span>, method: <span class="string">&quot;GET&quot;</span> | <span class="string">&quot;POST&quot;</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = &#123; <span class="attr">url</span>: <span class="string">&quot;https://example.com&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span> &#125;;</span><br><span class="line">handleRequest(req.url, req.method); <span class="comment">// error req.method 不是 &quot;GET&quot; | &quot;POST&quot; 类型 而是 string 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种方式解决</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 在任意位置使用类型断言</span></span><br><span class="line"><span class="comment">// 1.1 第一种 始终保持 req.method 拥有文字类型 &quot;GET&quot; 防止之后可能赋值其他类型 例如 POSt</span></span><br><span class="line"><span class="keyword">const</span> req = &#123; <span class="attr">url</span>: <span class="string">&quot;https://example.com&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span> <span class="keyword">as</span> <span class="string">&quot;GET&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 1.2 第二种 我知道有其他原因 `req.method` 具有 GET 值</span></span><br><span class="line">handleRequest(req.url, req.method <span class="keyword">as</span> <span class="string">&quot;GET&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 将整对象转为文字类型</span></span><br><span class="line"><span class="keyword">const</span> req = &#123; <span class="attr">url</span>: <span class="string">&quot;https://example.com&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// req的类型实际上是 &#123; url: &quot;https://example.com&quot;; method: &quot;GET&quot; &#125; 可以这样理解</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="null-和-undefined"><code>null</code> 和 <code>undefined</code></h3><ol><li><p><code>js</code> 中 <code>null</code> 和 <code>undefined</code> 表示不存在或未初始化的值</p></li><li><p><code>ts</code> 中有两个对应的同名类型，这些类型的行为取决于是否设置了 <code>strictNullChecks</code> 选项</p><ul><li>关闭 <code>false</code> 依然可以正常访问的值，并且可以将值分配给任何类型的属性。这类似没有空检查的语言 (<code>c#</code> <code>java</code>)，缺少空检查往往是错误的主要来源</li><li>开启，需要在对值使用之前测试这些值，就像在使用可选属性之前检查一样，我们需要使用缩小来检查可能的值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSome</span>(<span class="params">x: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;x is null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;x is string&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(x.length);</span><br><span class="line">        <span class="built_in">console</span>.log(x.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非空断言运算符 (<code>!</code> 后缀)</p><ul><li><code>ts</code> 的特殊语法，可以在不进行任何显式检查下，使用值</li><li><code>!</code> 在任何表达式之后写入实际上是一种类型断言，表示该值 我知道它由于某种原因它不是 <code>null</code> 或 <code>undefined</code></li><li>就像类型断言一样，它不会更改代码的运行时行为，因此仅当你知道它不是 <code>null</code> 或 <code>undefined</code> 时才应该使用非空断言运算符，这才是重要的</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">liveDangerous</span>(<span class="params">x?: <span class="built_in">number</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x!.toFixed(<span class="number">2</span>)); <span class="comment">// 我知道 x 是 number 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="枚举">枚举</h3><ol><li>枚举是 <code>ts</code> 添加到 <code>js</code> 中的一个功能，它允许描述一个值，该值是一组可能的命名常量之一。</li><li>关于枚举更深层次的使用</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="number">1</span>,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Direction.Up); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Direction.Down); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Up&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Down&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Left&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Right&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(Direction.Up);</span><br><span class="line"><span class="built_in">console</span>.log(Direction.Down);</span><br></pre></td></tr></table></figure><h3 id="不太常见的原语">不太常见的原语</h3><h4 id="bigint"><code>bigint</code></h4><ol><li>从 <code>es2020</code> 开始，<code>js</code> 中有一个用来表示非常大的整数的原语 <code>BigInt</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bigNumber1: bigint = <span class="built_in">BigInt</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">let</span> bigNumber2: bigint = <span class="number">100n</span>;</span><br></pre></td></tr></table></figure><h4 id="symbol"><code>symbol</code></h4><ol><li><code>Symbol</code> 用来通过函数创建全局唯一引用</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy1: symbol = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sy2: symbol = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sy3 = <span class="built_in">Symbol</span>(<span class="string">&quot;ooo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sy4 = <span class="built_in">Symbol</span>(<span class="string">&quot;ooo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sy5 = <span class="built_in">Symbol</span>(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> sy6 = <span class="built_in">Symbol</span>(<span class="string">&quot;222&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sy1 === sy2) &#123;</span><br><span class="line">    <span class="comment">// 虽然这里也永远无法执行 但它不会报错</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11111</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sy3 === sy4) &#123;</span><br><span class="line">    <span class="comment">// 虽然这里也永远无法执行 但它不会报错</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">22222</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sy5 === sy6) &#123; <span class="comment">// error</span></span><br><span class="line">    <span class="comment">// 永远不会执行，因为此条件始终返回 `false`  因为类型 typeof sy1 和 typeof sy2 没有重叠</span></span><br><span class="line">    <span class="comment">// 这是不是和文字类型比较类似了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型缩小">类型缩小</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    reurn <span class="keyword">new</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + input; <span class="comment">// error</span></span><br><span class="line">    <span class="comment">// 运算符 + 不能应用于类型 string | number</span></span><br><span class="line">    <span class="comment">// 我们没有明确检查 padding 是否为 `number` 也没有处理它是 string 的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型缩小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这看起来和无聊的 JS 一样，但是 `TS` 的类型主旨在于编写典型的 `JS` 代码尽可能容易，而不需要弯腰去获取类型安全</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TS 使用静态类型分析运行的值一样，它在 JS 的运行时控制流构造上构造叠加了类型分析 </span></span><br><span class="line"><span class="comment">if else 三元运算 循环 真值 等 这些都会影响到这些类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在使用 typeof padding === &quot;number&quot; 时可以理解为一种特殊形式的代码，称为类型保护</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TS 遵循程序可能采取的执行路径，来分析一个值在特定位置的最具体的可能类型</span></span><br><span class="line"><span class="comment">它查看这些特殊的检查和赋值，将类型细化为比声明更具体的类型的过程称为缩小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">那么主要有以下几种缩小</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="typeof-类型守卫"><code>typeof</code> 类型守卫</h3><ol><li><code>typeof</code> 和 <code>js</code> 运算符一样，它可以提供有关我们运行时拥有的值类型的非常基本的信息。<code>ts</code> 期望它返回一组特定的字符串<ul><li><code>string</code></li><li><code>number</code></li><li><code>bigint</code></li><li><code>boolean</code></li><li><code>symbol</code></li><li><code>undefined</code></li><li><code>object</code></li><li><code>function</code></li></ul></li><li>在 <code>TS</code> 使用 <code>typeof</code> 可以理解为，它缩小在不同分支中的类型</li><li>在 <code>typescript</code> 中检查 <code>typeof</code> 的返回值是一种类型保护</li><li>注意 <code>typeof</code> 不返回字符串 <code>null</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123; <span class="comment">// error 因为 它可能是 null</span></span><br><span class="line">            <span class="built_in">console</span>.log(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(strs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真值缩小">真值缩小</h3><ol><li><p>真值检查通常在 <code>js</code> 我们也会这样做: <code>&amp;&amp;</code> <code>||</code> <code>if</code> <code>!</code> 等表达式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonCount</span>(<span class="params">count: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`There are <span class="subst">$&#123;count&#125;</span> people`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;There are no people&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样通过 <code>if</code> 语句将它们的条件强制转化为 <code>boolean</code> 使它有意义，然后根据结果是 <code>true</code> <code>false</code> 来选择它们的分支</p></li><li><p>下面这些值将会强制转换为 <code>false</code>。其他值被转换为 <code>true</code>，你始终可以在 <code>Boolean</code> 函数中运行值获得 <code>boolean</code> 或使用较短的双布尔否定将值强制转换为 <code>boolean</code>，当然双重否定的优点在于 <code>ts</code> 将它推断为一个 <code>true</code> 的文字类型 比较狭窄 而 <code>Boolean</code> 是一个 <code>boolean</code> 类型</p><ul><li><code>0</code></li><li><code>NaN</code></li><li><code>&quot;&quot;</code></li><li><code>0n</code></li><li><code>null</code></li><li><code>undefined</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// boolean</span></span><br><span class="line">!!<span class="string">&quot;1&quot;</span>; <span class="comment">// true 类型</span></span><br></pre></td></tr></table></figure></li><li><p>利用真值缩小可以防范于 <code>null</code> <code>undefined</code> 之类的值的影响</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs &amp;&amp; <span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(strs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是对原语的真值检查通常容易出错</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这样排除了 空字符串和 null</span></span><br><span class="line">    <span class="keyword">if</span> (strs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(strs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个真值缩小的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyAll</span>(<span class="params">values: <span class="built_in">number</span>[] | <span class="literal">undefined</span>, factor: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!values) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> values.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * factor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="等值缩小">等值缩小</h3><ol><li><p>使用 <code>===</code> <code>!==</code> <code>!=</code> <code>==</code> 等值检查来实现类型缩小，叫等值缩小</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span>, y: <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">        <span class="comment">// 我们可以确定 x 和 y 具有相同的类型 string</span></span><br><span class="line">        x.toUpperCase(); <span class="comment">// 因为 x 和 y 具有相同的类型 所以可以调用 toUpperCase()</span></span><br><span class="line">        y.toUpperCase(); <span class="comment">// 因为 x 和 y 具有相同的类型 所以可以调用 toUpperCase()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">        <span class="built_in">console</span>.log(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在真值缩小中我们使用了一个不完善的缩小从而将空字符串从其中排除掉了，那么我们可以使用等值缩小进行完善</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(strs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>js</code> 更宽松的相等性检查 <code>==</code> <code>!=</code> 也能正确缩小。如果要检查一个变量是否等于 <code>null</code> 或 <code>undefined</code> 那么使用 <code>!=</code> 或 <code>==</code> 是一个好的方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Container &#123;</span><br><span class="line">    value: <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyValue</span>(<span class="params">container: Container, factor: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (container != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(container.value);</span><br><span class="line">        container.value *= factor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="in-操作符缩小"><code>in</code> 操作符缩小</h3><ol><li><p><code>in</code> 运算符，用于确定对象是否拥有某个名称的属性</p></li><li><p><code>value in x</code> <code>value</code> 是字符串文字，<code>x</code> 是类型，值为 <code>true</code> 的分支缩小，需要 <code>x</code> 具有可选或必需属性的类型的值，值为 <code>false</code> 的分支缩小，需要具有可选或缺失属性的值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fish = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> Bird = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">animal: Fish | Bird</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">        <span class="keyword">return</span> animal.swim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> animal.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human = &#123; swim?: <span class="function">() =&gt;</span> <span class="built_in">void</span>; fly?: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move1</span>(<span class="params">animal: Human | Fish | Bird</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">        <span class="comment">// Fish Human</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;fly&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">        <span class="comment">// Bird Human</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="instanceof-操作符缩小"><code>instanceof</code> 操作符缩小</h3><ol><li><code>instanceof</code> 检查一个值是否是另一个值的实例。更具体的 <code>x instanceof Foo</code> 检查 <code>x</code> 的原型链中是否含有 <code>Foo.prototype</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logValue</span>(<span class="params">x: <span class="built_in">Date</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x.toUTCString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分配缩小">分配缩小</h3><ol><li><p>我们在为任何变量赋值时，<code>TypeScript</code> 会查看赋值的右侧并适当缩小左侧</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ? <span class="number">10</span> : <span class="string">&quot;hello world&quot;</span>; <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;goodbye&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line">x = <span class="literal">false</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p>注意，这些分配中的每一个都是有效的，即使在我们第一次赋值后观察到 <code>x</code> 更改为 <code>number</code> 我们仍然可以将 <code>string</code> 赋值给 <code>x</code> ，这是因为 <code>x</code> 在声明时是 <code>string | number</code></p></li></ol><h3 id="控制流分析">控制流分析</h3><ol><li>通过分析代码流程进行缩小类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// padding是数字的情况下，下面这行代码不会执行 所以这里只能是类型 string 这就是 控制流分析</span></span><br><span class="line">    <span class="keyword">return</span> padding + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用类型谓词">使用类型谓词</h3><ol><li><p>为了定义一个用户定义的类型保护，我们需要定义一个函数，其返回类型是一个类型谓词</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fish = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    swim: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bird = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    fly: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (pet <span class="keyword">as</span> Fish).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pet is Fish 是类型谓词 形式是 `parameterName is Type` 其中 `parameterName` 是一个形式参数的名称，`Type` 是一个类型名称</span></span><br><span class="line"><span class="comment">// 任何时候 isFish 被调用时，如果原始类型是兼容的，`ts` 将把变量缩小到该特定类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fish: Fish = &#123;</span><br><span class="line">        name: <span class="string">&quot;gold fish&quot;</span>,</span><br><span class="line">        swim: <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bird: Bird = &#123;</span><br><span class="line">        name: <span class="string">&quot;bird&quot;</span>,</span><br><span class="line">        fly: <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> ? bird : fish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> underWater1: Fish[] = zoo.filter(isFish);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// const underWater1: Fish[] = zoo.filter(isFish) as Fish[];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> underWater2: Fish[] = zoo.filter((pet): pet is Fish =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (pet.name === <span class="string">&quot;frog&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isFish(pet);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="受歧视的-unions">受歧视的 <code>unions</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    kind: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">    radius?: <span class="built_in">number</span>;</span><br><span class="line">    sideLength?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shape.kind === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 依然不可以直接使用 radius 因为它是可选的</span></span><br><span class="line">        <span class="comment">// 但实际上我们知道 kind 是 circle 时，一定有 radius，这样要么使用 非空断言 要么 使用类型保护</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius! ** <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shape.sideLength! ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但实际上是不理想的，理想的状态应该是 kind 是 `circle` 一定有 `radius` 是 `square` 一定有边长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们需要将 <code>Shape</code> 分成两种类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle = &#123;</span><br><span class="line">    kind: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square = &#123;</span><br><span class="line">    kind: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Circle | Square;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shape.kind === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius ** <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shape.sideLength ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就摆脱了错误</span></span><br></pre></td></tr></table></figure><ol><li>当联合类型中的每个类型都包含一个与文字类型相同的属性时，<code>ts</code> 认为这是一个有区别的联合类型，并且可以缩小联合类型的成员</li><li>上面的例子 <code>kind</code> 是公共成员，检查 <code>kind</code> 是 <code>circle</code> 就可以剔除 <code>Shape</code> 中所没有 <code>circle</code> 类型属性的类型，同样的检查也适用于 <code>switch</code> 语句</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius ** <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> shape.sideLength ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="never-类型与穷尽性检查"><code>never</code> 类型与穷尽性检查</h3><ol><li><p>在缩小范围中，可以将一个联合体的选项减少到已经删掉了所有可能性并且什么都不剩的程度，在这种情况下，我们可以将其称为 <code>never</code> 类型 不存在的状态</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius ** <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> shape.sideLength ** <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">const</span> _exhaustiveCheck: <span class="built_in">never</span> = shape;</span><br><span class="line">            <span class="keyword">return</span> _exhaustiveCheck;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="函数更多">函数更多</h2><p>函数是任何程序的基本构件</p><h3 id="函数类型表达式">函数类型表达式</h3><ol><li>描述一个函数的最简单的方法就是用一个函数类型表达式。这些类型在语法上类似于箭头函数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">fn: (a: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    fn(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printToConsole</span>(<span class="params">s: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greeter(printToConsole);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn: (a: string) =&gt; void 一个string 参数的函数 没有返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然我们也可以使用一个类型来命名一个函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GreetFunction = <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">fn: GreetFunction</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用签名">调用签名</h3><ol><li>在 <code>js</code> 中，函数除了可以调用以外，还可以拥有属性。然后，函数类型表达式的语法不允许声明属性。如果我们想用属性来描述可调用的东西，我们可以在一个对象类型中写入一个调用签名</li><li>注意，和函数类型表达式相比，语法略有不同：在参数列表和返回类型之间使用 <code>:</code> 而不是 <code>=&gt;</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DescriptionFunction = &#123;</span><br><span class="line">    description: <span class="built_in">string</span>;</span><br><span class="line">    (num: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">fn: DescriptionFunction</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">num: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.description = <span class="string">&quot;1111&quot;</span>;</span><br><span class="line"></span><br><span class="line">isOdd(fn);</span><br></pre></td></tr></table></figure><h3 id="构造签名">构造签名</h3><ol><li><p><code>js</code> 函数也可以使用 <code>new</code> 操作符来调用，<code>typescript</code> 称为构造函数，它们通常会创建一个新的对象，你可以通过在调用签名前面添加 <code>new</code> 关键字来写一个构造签名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ctor</span> </span>&#123;</span><br><span class="line">    s: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">s: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SomeConstructor = &#123;</span><br><span class="line">    <span class="keyword">new</span> (s: <span class="built_in">string</span>): Ctor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">ctor: SomeConstructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = fn(Ctor);</span><br><span class="line"><span class="built_in">console</span>.log(f.s);</span><br></pre></td></tr></table></figure></li><li><p>还有些对象，如 <code>Date</code> 对象，可以在有 <code>new</code> 或没有 <code>new</code> 的情况下被调用，那么可以在同一类型中结合调用签名和构造签名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> DateFunction &#123;</span><br><span class="line">    <span class="keyword">new</span> (s: <span class="built_in">string</span>): <span class="built_in">Date</span>;</span><br><span class="line">    (t: <span class="built_in">number</span>): <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDate</span>(<span class="params">fn: DateFunction</span>): <span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">new</span> fn(<span class="string">&quot;2024-12-10&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> t = fn(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, <span class="attr">minute</span>: <span class="built_in">number</span>): ClockInerface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInerface &#123;</span><br><span class="line">    tick(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    ctor: ClockConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">    hour: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    minute: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ClockInerface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigitalClock</span> <span class="title">implements</span> <span class="title">ClockInerface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;beep beep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnalogClock</span> <span class="title">implements</span> <span class="title">ClockInerface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;tick tock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> c2 = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">c1.tick();</span><br><span class="line">c2.tick();</span><br></pre></td></tr></table></figure></li></ol><h3 id="泛型函数">泛型函数</h3><ol><li><p>在写一个函数时，输入的类型与输出的类型有关，或者两个输入的类型以某中方式相关，那么就可以使用泛型函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstElement</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstElement1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr: T[]</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstElemet([]));</span><br><span class="line"><span class="built_in">console</span>.log(firstElemet([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(firstElemet([<span class="string">&quot;str1&quot;</span>]));</span><br></pre></td></tr></table></figure></li></ol><h4 id="类型推断">类型推断</h4><ol><li>在上面的例子中我们没有指定类型，类型是由 <code>ts</code> 自动推断出来的，当然也可以使用多个类型参数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">Input</span>, <span class="title">Output</span>&gt;(<span class="params">arr: Input[], func: (arg: Input) =&gt; Output</span>): <span class="title">Output</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parsed = map([<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>], <span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">parseInt</span>(n));</span><br></pre></td></tr></table></figure><h4 id="限制条件">限制条件</h4><ol><li><p>我们可以对任何类型的值进行操作，有时我们想把两个值联系起来，但只能对某个值的子集进行操作，在这种情况下，我们可以使用一个约束条件来限制一个类型参数可以接受的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longest</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123; length: <span class="built_in">number</span> &#125;&gt;(a: T, <span class="attr">b</span>: T) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt;= b.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(longest([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(longest(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world123&quot;</span>));</span><br><span class="line">longest(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p>在上面的例子中，有一些有趣的事情需要注意，我们允许 <code>Ts</code> 推断 <code>longest</code> 的返回类型，返回类型推断也适用于通用函数，我们将 <code>T</code> 约束为 <code>&#123; length: number &#125;</code>，所以我们才可以访问 <code>a</code> <code>b</code> 两个参数的 <code>.length</code> 属性，如果没有类型约束，我们不可以访问这些属性，因为这些值可能是一些没有长度属性的其他类型</p></li><li><p><code>Array</code> <code>string</code> 的类型是根据参数推断出来的，所以泛型就是把两个或多个具有相同类型的值联系起来</p></li><li><p>最后，正如我们希望的，<code>longest(10, 20)</code> 会报错，因为数字类型没有 <code>.length</code> 属性</p></li></ol><h4 id="使用受限值">使用受限值</h4><ol><li><p>这里有一个适用通用约束条件的常见错误</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minimumLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123; length: <span class="built_in">number</span> &#125;&gt;(obj: T, <span class="attr">minimum</span>: <span class="built_in">number</span>): T &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.length &gt;= minimum) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">length</span>: minimum &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>看起来上面的函数是没有问题的，<code>T</code> 被限制为 <code>&#123; length: number &#125;</code>，而且这个函数要么返回 <code>T</code> 要么返回一个与该限制相匹配的值，问题是，该函数承诺返回与传入参数相同的类型，而不仅仅是和约束条件想匹配的对象，如果这段代码是合法的，那么你可以得到这样一个无法工作的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = minimumLength([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li></ol><h4 id="指定类型参数">指定类型参数</h4><ol><li><p><code>TS</code> 通常可以推断出通用调用中的预期类型参数，但并非总是如此</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr1: T[], arr2: T[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr1.concat(arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = combine([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]); <span class="comment">// error 因为T首先被推断为 number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你非要这样做 指定类型参数是有必要的</span></span><br><span class="line"><span class="keyword">const</span> arr1 = combine&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure></li></ol><h4 id="编写优秀通用函数的准则">编写优秀通用函数的准则</h4><p>编写泛型函数很有趣，但是很容易被类型参数所迷惑，有太多的类型参数或在不需要的地方使用约束会使推理不那么成功</p><ol><li><p>类型参数下推</p><ul><li>规则: 在可能的情况下，使用类型参数本身，而不是对其进行约束</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstElement1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr: T[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstElement2</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">any</span>[]&gt;(<span class="params">arr: T</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个函数推断返回类型是 T 而第二个函数推断返回 any</span></span><br><span class="line"><span class="comment">// 因为 ts 必须使用约束类型来解析 arr[0] 表达式，而不是在调用期间 等待解析该元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = firstElement1([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// number</span></span><br><span class="line"><span class="keyword">let</span> b = firstElement2([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// any</span></span><br></pre></td></tr></table></figure></li><li><p>使用更少的类型参数</p><ul><li>规则: 总是尽可能少的使用类型参数</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr: T[], func: (arg: T) =&gt; <span class="built_in">boolean</span></span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种形式除了让函数更难看懂，没有任何用处</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter2</span>&lt;<span class="title">T</span>, <span class="title">Func</span> <span class="title">extends</span> (<span class="params">arg: T</span>) =&gt; <span class="title">boolean</span>&gt;(<span class="params">arr: T[], fn: Func</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型参数应出现两次</p><ul><li>规则: 如果一个类型的参数只出现在一个地方，请重新考虑是否真的需要</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>&lt;<span class="title">Str</span> <span class="title">extends</span> <span class="title">string</span>&gt;(<span class="params">s: Str</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello, &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么不直接使用 string 类型呢 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">s: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello, &quot;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="可选参数">可选参数</h3><ol><li><p><code>js</code> 中的函数经常需要一个可变数量的参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n.toFixed()); <span class="comment">// 0 个参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(n.toFixed(<span class="number">1</span>)); <span class="comment">// 1 个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1(); <span class="comment">// 正确</span></span><br><span class="line">fn1(<span class="number">10</span>); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>上面 <code>fn1</code> 函数参数 <code>x</code> 虽然指定为 <code>number</code> 但因为它是可选参数，所以它实际上具有 <code>number | undefined</code> 类型</p></li><li><p>也可以提供默认参数值，现在 <code>fn1</code> 的主体中，<code>x</code> 将具有 <code>number</code> 类型，因为任何 <code>undefined</code> 类型都会被替换为 <code>10</code></p></li><li><p>请注意，当一个参数是可选的，调用者总是可以传递未定义的参数，因为这只是模拟一个丢失的参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x?: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line">f();</span><br><span class="line">f(<span class="number">10</span>);</span><br><span class="line">f(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="回调中的可选参数">回调中的可选参数</h4><ol><li><p>一旦了解可选参数和函数类型表达式，在编写调用回调的函数时就很容易犯错</p></li><li><p>规则: 当为回调写一个函数类型时，永远不要写一个可选参数，除非你打算在不传递该参数的情况下它还可以工作</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        callback(arr[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在书写 index? 作为一个可选参数时，通常是想让这些调用是合法的</span></span><br><span class="line">myForEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="built_in">console</span>.log(a));</span><br><span class="line">myForEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> <span class="built_in">console</span>.log(a, i));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可是，如果调用者不想提供索引，并且回调中使用索引, 那么就会出现错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        callback(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myForEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i.toFixed()); <span class="comment">// error 因为 i 可能是 undefined 所以要让它不报错，要么你确定它一定有值使用非空断言 或者使用类型缩小</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数重载">函数重载</h3><ol><li><p>当一些函数可以在不同的参数数量和类型中被调用，可以通过编写重载签名来指定一个可以不同方式调用的函数，要做到这一点，要写一些数量的函数签名(通常是两个或多个)，然后是函数的主体</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDate</span>(<span class="params">timestamp: <span class="built_in">number</span></span>): <span class="title">Date</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDate</span>(<span class="params">m: <span class="built_in">number</span>, d: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">Date</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDate</span>(<span class="params">mOrTimestamp: <span class="built_in">number</span>, d?: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d !== <span class="literal">undefined</span> &amp;&amp; y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(y, mOrTimestamp, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(mOrTimestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeDate(<span class="number">12345678</span>);</span><br><span class="line">makeDate(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2024</span>);</span><br><span class="line">makeDate(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p>这里我们写了两个重载: 一个接受一个参数，另一个接受三个参数。前两个签名被称为重载签名，然后我们写了一个具有兼容签名的函数实现。函数有一个实现签名，但是这个签名不能被直接调用。即使我们写了一个所需参数之后有两个可选的参数，但是也不能以两个参数调用</p></li></ol><h4 id="重载签名和实现签名">重载签名和实现签名</h4><ol><li><p>这是一个常见的混乱来源</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望以零参数调用</span></span><br><span class="line"><span class="comment">// 但是错误，提示未提供 x 变量</span></span><br><span class="line">fn(); <span class="comment">// error</span></span><br><span class="line">fn(<span class="number">10</span>); <span class="comment">// 所以只能这样调用，那么这样使用重载签名的意义何在</span></span><br></pre></td></tr></table></figure></li><li><p>用于编写函数体的签名不能从外面看到</p><ul><li>实现的签名从外面是看不到的，在编写重载函数时，应该总是在函数的实现上有两个或两个以上的重载签名</li></ul></li><li><p>实现签名也必须与重载签名兼容</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">boolean</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">void</span></span>; <span class="comment">// error string boolean 不兼容 实现签名是 boolean 而 重载签名是 string 所以实现签名必须使用 联合类型才对</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">boolean</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>; <span class="comment">// 返回类型不兼容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ops&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="编写好的重载">编写好的重载</h4><ol><li><p>和泛型一样，在使用函数重载时，有一些准则需要遵循</p><ul><li>在可能的情况下，总是倾向于使用联合类型的参数而不是重载参数</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">s: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">len(<span class="string">&quot;srt&quot;</span>);</span><br><span class="line">len([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">len(<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">&quot;str&quot;</span> : [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实现签名是兼容的</span></span><br><span class="line"><span class="comment">// 我们可以使用 字符串或数组来调用它</span></span><br><span class="line"><span class="comment">// 但是我们不能使用可能是字符串或数组的值来调用它，因为 ts 只能将一个函数调用解析为一个重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为两个重载都有相同的参数数量和相同的返回类型，可以改写为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">x: <span class="built_in">any</span>[] | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">len(<span class="string">&quot;srt&quot;</span>);</span><br><span class="line">len([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">len(<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">&quot;str&quot;</span> : [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure></li></ol><h4 id="函数内-This-的声明">函数内 <code>This</code> 的声明</h4><ol><li><p><code>TypeScript</code> 会通过代码流分析来推断函数中的 <code>this</code> 应该是什么</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    id: <span class="number">123</span>,</span><br><span class="line">    admin: <span class="literal">false</span>,</span><br><span class="line">    becomeAdmin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.admin = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts 理解函数 user.becomeAdmin 有一个对应的 this 它是外部对象 user，这个对于很多情况下已经足够了，但是在某些情况下，我们需要明确的指定函数中的 this 类型</span></span><br><span class="line"><span class="comment">// js 规范中，不能有一个叫 `this` 的参数，所以 TypeScript 使用这个语法空间，让你在函数体中声明 this 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    admin: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> DB &#123;</span><br><span class="line">    filterUsers(filter: <span class="function">(<span class="params"><span class="built_in">this</span>: User</span>) =&gt;</span> <span class="built_in">boolean</span>): User[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db:DB = &#123;</span><br><span class="line">    filterUsers: <span class="function">(<span class="params">filter: (<span class="built_in">this</span>: User) =&gt; <span class="built_in">boolean</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> user1 = &#123;</span><br><span class="line">            admin: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> user2 = &#123;</span><br><span class="line">            admin: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [user1, user2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> admins = db.filterUsers(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">this</span>: User</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.admin;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是注意，需要使用函数而不是箭头函数</span></span><br><span class="line"><span class="keyword">const</span> admins1 = db.filterUsers(<span class="function">() =&gt;</span> <span class="built_in">this</span>.admin); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="需要了解的其他类型">需要了解的其他类型</h3><ol><li>一些函数的上下文中特别相关的类型</li></ol><h4 id="void"><code>void</code></h4><ol><li><p><code>void</code> 表示没有返回值的函数的返回值。当一个函数没有任何返回语句，或者没有从这些返回语句中返回任何明确的值时，它都是推断出来的类型</p></li><li><p>在 <code>js</code> 中，一个不返回任何值的函数将隐含的返回 <code>undefined</code> 的值，然而在 <code>ts</code> 中，<code>void</code> 和 <code>undefined</code> 是不一样的</p></li><li><p>记住 <code>void</code> 和 <code>undefined</code> 不一样</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断返回的类型是 void</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="object"><code>object</code></h4><ol><li>特殊类型 <code>object</code> 指的是任何不是基元的值 <code>string</code> <code>number</code> <code>bigint</code> <code>boolean</code> <code>symbol</code> <code>null</code> <code>undefined</code> 之外的。这和空对象类型 <code>&#123;&#125;</code> 不同，也与全局类型 <code>Object</code> 不同。你可能永远不会使用到 <code>Object</code></li><li><code>object</code> 不是 <code>Object</code> 始终使用 <code>object</code></li><li>注意：在 <code>js</code> 中，函数是对象，它们有属性，在它们的原型链上有 <code>Object.prototype</code>，是 <code>object</code> 的实例，可以对它们调用 <code>Object.keys</code>等。由于这些原因，函数类型在 <code>Typescript</code> 中被认为是 <code>object</code></li></ol><h4 id="unknown"><code>unknown</code></h4><ol><li><code>unknown</code> 类型代表任何值，这和 <code>any</code> 类型类似，但是更安全，因为对未知 <code>unknown</code> 值做任何事情都是不合法的</li><li>这对于描述函数类型非常有用，因为你可以描述接受任何值的函数，而不需要在函数体有 <code>any</code> 值。反之，你可以描述一个返回未知类型的值的函数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    a.b(); <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">a: unknown</span>) </span>&#123;</span><br><span class="line">    a.b(); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeParse</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = safeParse(<span class="string">&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;</span>); <span class="comment">// 要小心对待 obj</span></span><br></pre></td></tr></table></figure><h4 id="never"><code>never</code></h4><ol><li>有些函数永远不会返回一个值</li><li><code>never</code> 类型表示永远不会被观察到的值，在一个返回类型中，这意味着函数抛出一个异常或终止程序的执行</li><li><code>never</code> 也出现在 <code>TypeScript</code> 确定一个 <code>union</code> 中没有任何东西的时候</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x; <span class="comment">// never 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Function"><code>Function</code></h4><p>全局性的 <code>Function</code> 类型描述了诸如 <code>bind</code> <code>call</code> <code>apply</code> 和其他存在于 <code>JS</code> 中所有函数值的属性。它还有一个特殊的属性。即 <code>Function</code> 类型的值总是可以被调用，这些调用返回 <code>any</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个无类型的函数调用，一般来说最好避免，因为 any 返回类型都不安全</span></span><br><span class="line"><span class="comment">// 如果你需要接受一个任意的函数，但不打算调用它，一般来说 () =&gt; void 是安全的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">f: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数展开运算符">参数展开运算符</h3><h4 id="形参展开">形参展开</h4><ol><li>除了使用可选参数或重载来制作可以接受各种固定参数数量的函数外，还可以使用休止参数来定义接受无限制数量参数的函数</li><li><code>rest</code> 参数出现在所有其他参数之后，并使用 <code>...</code> 语法</li><li>在 <code>ts</code> 中，这些参数的类型注解是隐含的 <code>any[]</code> 而不是 <code>any</code>，任何给出的类型注解必须是 <code>Array&lt;T&gt;</code> 或 <code>T[]</code> 的形式，或一个元组类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mulitiply</span>(<span class="params">n: <span class="built_in">number</span>, ...m: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.map(<span class="function">(<span class="params">x</span>) =&gt;</span> n * x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = mulitiply(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="实参展开">实参展开</h4><ol><li><p>反之，我们可以使用 <code>spread</code> 语法从数组中提供可变数量的参数，例如，数组的 <code>push</code> 方法需要任意数量的参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure></li><li><p>请注意，一般来说 <code>TS</code> 并不假定数组是不可变的，这可能会导致一些意想不到的行为</p></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> angle = <span class="built_in">Math</span>.atan2(...args); <span class="comment">// error 它不认为 args的数量是两个即使使用了 const 进行定义 除非使用 as const</span></span><br></pre></td></tr></table></figure><h3 id="参数解构">参数解构</h3><ol><li><p>可以使用参数重构来方便的将作为参数提供的对象，解压到函数主体的一个或多个局部变量中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">&#123; a, b, c &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(&#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的类型注解在解构的语法之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">&#123; a, b, c &#125;: &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; c: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ABC = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; b: <span class="built_in">number</span>; c: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">&#123; a, b, c &#125;: ABC</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数的可分配性">函数的可分配性</h3><h4 id="返回-void-类型">返回 <code>void</code> 类型</h4><ol><li>函数的 <code>void</code> 返回类型可以产生一些不同寻常的行为，但却是预期的行为</li><li>返回类型 <code>void</code> 的上下文类型并不强迫函数不返回东西。另一种说法是，一个具有 <code>void</code> 返回类型的上下文函数类型 ( <code>type vf = () =&gt; void</code>)，在实现时，可以返回任何其他的值，但它会被忽略，因此，以下 <code>() =&gt; void</code> 类型的实现是有效的</li><li>需要注意，当一个字面的函数定义返回类型是 <code>void</code>，该函数不能返回任何东西</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f1: voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f2: voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f3: voidFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当这些函数之一的返回值被分配给另一个变量时，它将保留 void 类型</span></span><br><span class="line"><span class="keyword">const</span> v1 = f1();</span><br><span class="line"><span class="keyword">const</span> v2 = f2();</span><br><span class="line"><span class="keyword">const</span> v3 = f3();</span><br></pre></td></tr></table></figure><h2 id="对象类型-2">对象类型</h2><ol><li><p>在 <code>js</code> 中，我们分组和传递数据的基本方式是通过对象，我们通过对象类型来表示这些对象</p></li><li><p>对象类型可以是匿名的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + person.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + person.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者类型别名</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + person.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="属性修改器">属性修改器</h3><ol><li>对象类型中的每个属性都可以指定几件事: 类型、属性是否可选，以及属性是否可以被写入</li></ol><h4 id="可选属性-2">可选属性</h4><ol><li>在属性后使用 <code>?</code> 表示它是可选的</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PaintOptions &#123;</span><br><span class="line">    shape: Shape;</span><br><span class="line">    xPos?: <span class="built_in">number</span>;</span><br><span class="line">    yPos?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintShape</span>(<span class="params">opts: PaintOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shape: Shape = &#123;&#125;;</span><br><span class="line">paintShape(&#123; shape &#125;);</span><br><span class="line">paintShape(&#123; shape, <span class="attr">xPos</span>: <span class="number">100</span> &#125;);</span><br><span class="line">paintShape(&#123; shape, <span class="attr">yPos</span>: <span class="number">100</span> &#125;);</span><br><span class="line">paintShape(&#123; shape, <span class="attr">xPos</span>: <span class="number">100</span>, <span class="attr">yPos</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p>在 <code>js</code> 中，即使该属性从未被设置过，我们任然可以访问它-它只是为定义的值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintShape</span>(<span class="params">opts: PaintOptions</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xPos = opts.xPos || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> yPos = opts.yPos || <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这种未指定的值设置默认值非常普遍，以至于 <code>js</code> 有特殊的语法来支持它</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintShape</span>(<span class="params">&#123; shape, xPos = <span class="number">0</span>, yPos = <span class="number">0</span> &#125;: PaintOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 paintShape 的参数使用了解构，并未 x y提供了默认值，现在x,y肯定都</span></span><br><span class="line"><span class="comment"> * 存在于 paintShape 的主体中，但对于 `paintShape` 来说的任何调用者来说是可选的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：目前还没有办法将类型注释放在结构模式中，这是因为下面的语法在 js 中有了不同的含义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">&#123; shape: Shape, xPos: <span class="built_in">number</span> = <span class="number">100</span> &#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是将参数对象中的 shape 换成临时变量 Shape xPos 换成 number 标识符</span></span><br></pre></td></tr></table></figure><h4 id="只读属性">只读属性</h4><ol><li><p>对于 <code>TS</code> 属性可以被标记为只读，虽然它不会在运行时改变任何行为，但是在类型检查期间，一个标记为只读的属性不能被写入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SomeType &#123;</span><br><span class="line">    <span class="keyword">readonly</span> prop: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSome</span>(<span class="params">obj: SomeType</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.prop);</span><br><span class="line"></span><br><span class="line">    obj.prop = <span class="string">&quot;hello&quot;</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>readonly</code> 修饰符并不一定意味着一个值是完全不可改变的，或者换句话说，它的内部内容不能被改变，它只意味着该属性本身不能被重新写入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Home &#123;</span><br><span class="line">    <span class="keyword">readonly</span> resident: &#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        age: <span class="built_in">number</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visitForBirthday</span>(<span class="params">home: Home</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Happy $&#123;home.resident.age&#125; Birthday $&#123;home.resident.name&#125;&quot;</span>);</span><br><span class="line">    home.resident.age++; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evict</span>(<span class="params">home: Home</span>) </span>&#123;</span><br><span class="line">    home.resident = &#123;</span><br><span class="line">        name: <span class="string">&quot;Victor the Evictor&quot;</span>,</span><br><span class="line">        age: <span class="number">42</span>,</span><br><span class="line">    &#125;; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>管理对 <code>readonly</code> 含义的预期很重要，在 <code>ts</code> 开发中，对于一个对象应该如何被使用的问题，它是有用的信号。<code>ts</code> 在检查两个类型的属性是否兼容时，并不考虑这些类型的属性是否是 <code>readonly</code> 所以 <code>readonly</code> 属性也可以通过别名来改变</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ReadonlyPerson &#123;</span><br><span class="line">    <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> writeblePerson: Person = &#123;</span><br><span class="line">    name: <span class="string">&quot;Person McPersonface&quot;</span>,</span><br><span class="line">    age: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readonlyPerson: ReadonlyPerson = writeblePerson;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(readonlyPerson.age);</span><br><span class="line">writeblePerson.age++;</span><br><span class="line"><span class="built_in">console</span>.log(readonlyPerson.age);</span><br></pre></td></tr></table></figure></li></ol><h4 id="索引签名">索引签名</h4><ol><li><p>有时并不提前知道一个类型的所有属性名称，但知道值的形状，在这种情况下，可以使用索引签名来描述可能的值的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [index: number] 索引属性，表示当一个 StringArray 被数字索引时，返回一个字符串</span></span><br><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p>索引签名的属性类型必须是 <code>string</code> 或 <code>number</code></p></li><li><p>支持两种类型的索引器是可能的，但是从数字索引器返回的类型必须是字符串索引器返回的类型的子类型。这是因为当用 <code>number</code> 进行索引时，<code>js</code> 实际上会在索引到一个对象之前将其转换为 <code>string</code>。这意味着用 <code>100</code> 进行索引和用 <code>'100'</code> 进行索引是一样的，所以两者需要一致</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> NotOkay &#123;</span><br><span class="line">    [x: <span class="built_in">number</span>]: Animal; <span class="comment">// 错误 number 索引返回 Animal 而 string 索引返回 Dog, Animal 不是 Dog 的子类型</span></span><br><span class="line">    [x: <span class="built_in">string</span>]: Dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> YesKey &#123;</span><br><span class="line">    [x: <span class="built_in">number</span>]: Dog;</span><br><span class="line">    [x: <span class="built_in">string</span>]: Animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>虽然字符串索引签名是描述字典模式的一种强大方式，但它也强制要求所有的属性与它们的返回类型想匹配。这是因为字符串索引声明 <code>obj.proerty</code> 也可以作为 <code>obj[&quot;property&quot;]</code> 在下面的例子中，<code>name</code> 的类型与字符串索引的类型不匹配</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">    length: <span class="built_in">number</span>; <span class="comment">// ok</span></span><br><span class="line">    name: <span class="built_in">string</span>; <span class="comment">// error 类型 string 的属性不能赋值给 string 索引类型 number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然而，如果索引类型是属性类型的联合，不同类型的属性是可以接受的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberOrStringDictionary &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line">    length: <span class="built_in">number</span>; <span class="comment">// ok</span></span><br><span class="line">    name: <span class="built_in">string</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，索引签名也可以为只读属性，以防止对其索引的赋值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array: ReadonlyStringArray = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>];</span><br><span class="line">array[<span class="number">2</span>] = <span class="string">&quot;3&quot;</span>; <span class="comment">// error readonly</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="扩展类型">扩展类型</h3><ol><li><p>有些类型可能是其他类型的更具体的版本</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> BasicAddress &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    street: <span class="built_in">string</span>;</span><br><span class="line">    city: <span class="built_in">string</span>;</span><br><span class="line">    country: <span class="built_in">string</span>;</span><br><span class="line">    postalCode: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在需要一个地址的单元</span></span><br><span class="line"><span class="keyword">interface</span> AddressWithUnit <span class="keyword">extends</span> BasicAddress &#123;</span><br><span class="line">    unit: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口的 <code>extends</code> 关键字，允许我们有效地从其他命名的类型中复制成员，并添加我们想要的任何新成员，这对于减少重复非常有用，以及表明同一属性的几个不同声明可能是相关的意图来说，是非常有用的</p></li><li><p>接口也可以从多个类型中扩展</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Colorful &#123;</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ColorfulCircle <span class="keyword">extends</span> Colorful, Circle &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc: ColorfulCircle = &#123;</span><br><span class="line">    color: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    radius: <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="交叉类型">交叉类型</h3><ol><li><p>接口允许通过扩展其他类型建立新的类型。而交叉类型可以通过组合其他类型建立新的类型</p></li><li><p>交叉类型用 <code>&amp;</code> 操作符定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Colorful &#123;</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColorfulCircle = Colorful &amp; Circle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc: ColorfulCircle = &#123;</span><br><span class="line">    color: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">    radius: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">circle: ColorfulCircle</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(circle.color);</span><br><span class="line">    <span class="built_in">console</span>.log(circle.radius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw(&#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">radius</span>: <span class="number">100</span> &#125;);</span><br><span class="line">draw(cc);</span><br></pre></td></tr></table></figure></li></ol><h3 id="接口与交叉类型">接口与交叉类型</h3><ol><li>接口扩展和交叉类型非常相似，但实际上有些细小的不同，对于接口，我们可以使用 <code>extends</code> 子句来扩展其他类型，而对于交叉类型，我们也可以做类似的事，并用类型别名来命名新类型。</li><li>两者之间的主要区别在于如何处理冲突，这种区别通常是在接口和交叉类型的类型别名之间选择的一个主要原因</li></ol><blockquote class="mindmap" style="height:400px;contenteditable:true"><ul><li>接口 VS. 交叉类型<ul><li>相同点<ul><li>都可以描述对象或函数</li><li>都可以扩展其他类型</li></ul></li><li>区别<ul><li>不同的声明范围<ul><li>接口: 声明中，值是具体结构对象</li><li>交叉: 可以为任意的类型创建类型别名</li></ul></li><li>不同的扩展形式<ul><li>接口: extends</li><li>交叉: &amp;</li></ul></li><li>不同的重复定义表现形式<ul><li>接口: 自动合并</li><li>交叉: 报错</li></ul></li></ul></li><li>如何选择<ul><li>建议优先选择接口</li><li>接口满足不了再使用交叉类型</li></ul></li></ul></li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口可以定义多次，多次的声明会自动合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Sister &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Sister &#123;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> si: Sister = &#123; <span class="comment">// error 缺少 age 属性</span></span><br><span class="line">    name: <span class="string">&quot;suxi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sis: Sister = &#123;</span><br><span class="line">    name: <span class="string">&quot;suxi&quot;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名定义多次会报错</span></span><br><span class="line"><span class="keyword">type</span> Sister = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sister = &#123; <span class="comment">// error 不可以重复定义类型</span></span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范型对象类型">范型对象类型</h3><ol><li><p>如果有一个包含任何数据的盒子类型: 字符串、数字、苹果</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// any</span></span><br><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">    contents: <span class="built_in">any</span>; <span class="comment">// any 但是ts的类型检查就失效了 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 unknown</span></span><br><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">    contents: unknown; <span class="comment">// 虽然安全，但是使用时需要进行类型缩小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> box: Box = &#123;</span><br><span class="line">    contents: <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> box.contents === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(box.contents.toUpperCase());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(box.contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每一个盒子搭建不同的类型</span></span><br><span class="line"><span class="keyword">interface</span> NumberBox &#123;</span><br><span class="line">    contents: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StringBox &#123;</span><br><span class="line">    contents: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BooleanBox &#123;</span><br><span class="line">    contents: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但这也意味着我们必须创建不同的函数或函数的重载，对这些结构类似的类型进行操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setContents</span>(<span class="params">box: NumberBox, newContents: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setContetns</span>(<span class="params">box: StringBox, newContents: <span class="built_in">string</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setContents</span>(<span class="params">box: BooleanBox, newContents: <span class="built_in">boolean</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setContents</span>(<span class="params">box: &#123; contents: <span class="built_in">any</span> &#125;, newContents: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    box.contents = newContents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果以后需要引入更多类型的盒子，这是非常差劲的</span></span><br><span class="line"><span class="comment">// 相反我们可以做一个通用的 Box 类型，声明一个类型参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Box&lt;T&gt; &#123;</span><br><span class="line">    contents: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> box1 = Box&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">    contents: <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> box2 = Box&lt;<span class="built_in">boolean</span>&gt; = &#123;</span><br><span class="line">    contents: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 盒子是可重用的，因为 T 可以用任何东西来代替，这意味着当我们需要一个新类型的盒子时，我们根本不需要一个新的盒子类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Apple &#123;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> appleBox: Box&lt;Apple&gt; = &#123;</span><br><span class="line">    contents: &#123;</span><br><span class="line">        weight: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 意味着我们也可以完全避免重载，而使用通用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setContents</span>&lt;<span class="title">T</span>&gt;(<span class="params">box: Box&lt;T&gt;, contents: T</span>) </span>&#123;</span><br><span class="line">    box.contents = contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>值得注意的是，类型别名也可以通用的，我们可以通过使用类型别名来代替</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Box&lt;T&gt; = &#123;</span><br><span class="line">    contents: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于类型别名与接口不同，它不仅可以描述对象类型，还可以用它来编写其他类型的通用辅助类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OrNull&lt;T&gt; = T | <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">type</span> OneOrMany&lt;T&gt; = Type | Type[];</span><br><span class="line"><span class="keyword">type</span> OneOrManyOrNull&lt;T&gt; = orNull&lt;OneOrMany&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> OneOrManyOrNullStrings = OneOrManyOrNull&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure></li><li><p>通用对象类型通常是某种容器类型，它的工作与它们所包含的元素类型无关。数据结构以这种形式工作是理想的，这样它们就可以在不同的数据类型中重复使用</p></li></ol><h3 id="数组类型">数组类型</h3><ol><li><p>我们一直在使用这样一种类型: 数组类型，<code>number[]</code> <code>string[]</code> 这种类型 实际上是 <code>Array&lt;number&gt;</code> 和 <code>Array&lt;string&gt;</code> 的缩写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSome</span>(<span class="params">value: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: <span class="built_in">string</span>[] = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hell&quot;</span>];</span><br><span class="line"></span><br><span class="line">doSome(myArray);</span><br></pre></td></tr></table></figure></li><li><p>和上面的 <code>Box</code> 类型一样，<code>Array</code> 本身也是一个通用类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Array&lt;T&gt; &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">    pop(): T | <span class="literal">undefined</span>;</span><br><span class="line">    push(...items: T[]): <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现代 <code>JS</code> 还提供了其他通用的数据结构，比如 <code>Map&lt;K, V&gt;</code> <code>Set&lt;T&gt;</code> <code>Promise&lt;T&gt;</code> 。这意味着，由于 <code>Map</code> <code>Set</code> <code>Promise</code> 的行为方式，它们可以与任何类型的集合一起工作</p></li></ol><h3 id="只读数组类型">只读数组类型</h3><ol><li><p><code>ReadonlyArray</code> 是一个特殊的类型，描述了不应该被改变的数组</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params">values: ReadonlyArray&lt;<span class="built_in">string</span>&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> copy = values.slice();</span><br><span class="line">    <span class="built_in">console</span>.log(values[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    values.push(<span class="string">&quot;hello&quot;</span>); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>和属性的 <code>readonly</code> 修饰符一样，它主要是我们用来了解意图的工具。当我们看到一个返回 <code>ReadonlyArray</code> 的函数时，我们知道我们不能改变它的内容。当我们看一个接受 <code>ReadonlyArray</code> 的函数的时候，我们可以将任何数组传入而不用担心它会改变其内容</p></li><li><p>和 <code>Array</code> 不同，没有一个我们可以使用的 <code>ReadonlyArray</code> 构造函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ReadonlyArray(<span class="string">&quot;red&quot;</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p>相反，我们可以将普通的 <code>Array</code> 分配给 <code>ReadonlyArray</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> roArray: ReadonlyArray&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p>正如 <code>TypeScript</code> 为 <code>Array&lt;T&gt;</code> 提供了 <code>T[]</code> 的速记语法一样，它也为 <code>ReadonlyArray&lt;T&gt;</code> 提供了只读 <code>Type[]</code> 的速记语法一样</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params">values: <span class="keyword">readonly</span> <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> copy = values.slice();</span><br><span class="line">    values.push(<span class="string">&quot;hllo&quot;</span>); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后需要注意的是，与 <code>readonly</code> 属性修改器不同，可分配性在普通 <code>Array</code> 和 <code>ReadonlyArray</code> 之间不是双向的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="keyword">readonly</span> <span class="built_in">string</span>[] = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> y: strng[] = [];</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">// 非readonly 可以分配给 readonly</span></span><br><span class="line">y = x; <span class="comment">// error readonly 不可以分配给非readonly</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="元组类型">元组类型</h3><ol><li><p><code>Tuple</code> 类型是另一种 <code>Array</code> 类型，它确切地知道包含多少元素，以及它在特定位置包含哪些类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringNumberPair 是一个 string number 的元组类型，和 ReadonlyArray 一样它在运行时没有任何表示，但对 ts 来说 它描述了其索引 0 包含字符串 和索引1 包含数字的数组</span></span><br><span class="line"><span class="keyword">type</span> StringNumberPair = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果我们试图索引超过元素的数量，我们会得到一个错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSuff</span>(<span class="params">pair: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c = pair[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用数组析构来对元组进行解构</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSuff</span>(<span class="params">pair: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [str, num] = pair;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>除了长度检查，像这样的简单元组类型等同于 <code>Array</code> 的版本，它为特定的索引声明属性，并且用数字字面类型声明长度</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringNumberPair &#123;</span><br><span class="line">    length: <span class="number">2</span>;</span><br><span class="line">    <span class="number">0</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// 其他 Array&lt;string | number&gt; 成员</span></span><br><span class="line">    slice(start?: <span class="built_in">number</span>, end?: <span class="built_in">number</span>): <span class="built_in">Array</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li><li><p>元组可以通过在元素的类型后面写出问号 <code>?</code> ---- 可选的元组，元素只能出现在末尾，而且还影响到长度的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Either2dOr3d = [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>?];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCoordinate</span>(<span class="params">coord: Either2dOr3d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [x, y, z] = coord;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>元组也可以有其余元素，这些元素必须是 <code>array/tuple</code> 类型</p><ul><li><code>StringNumberBooleans</code> 描述了一个元组，其前两个元素分别是字符串和数字，但后面可以有任意数量的布尔</li><li><code>StringBooleansNumber</code> 描述了一个元组，其第一个元素是字符串，最后一个元素是数字，中间可以是任意数量的布尔</li><li><code>BooleansStringNumber</code> 描述了一个元组，其倒数第二个元素是字符串，最后一个元素是数字，起始位置可以是任意数量的布尔</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringNumberBooleans = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...boolean[]];</span><br><span class="line"><span class="keyword">type</span> StringBooleansNumber = [<span class="built_in">string</span>, ...boolean[], <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> BooleansStringNumber = [...boolean[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure></li><li><p><code>ts</code> 允许将 <code>tuples</code> 与参数列表想对应。当想用一个其余参数接受可变数量的参数，并且需要一个最小的元素数量，但不想引人中间变量时，这很方便</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readButtonInput</span>(<span class="params">...args: [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readButtonInput</span>(<span class="params">name: <span class="built_in">string</span>, version: <span class="built_in">number</span>, ...input: <span class="built_in">boolean</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="只读元组类型">只读元组类型</h3><ol><li><p><code>tuple</code> 类型有只读特性，可以通过在它们前面添加一个 <code>readonly</code> 关键字修饰符来指定</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doS</span>(<span class="params">pair: <span class="keyword">readonly</span> [<span class="built_in">string</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">    pair[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span>; <span class="comment">// error 不可写入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在大多数代码中，元组往往被创建并不被修改，所以在可能的情况下，将类型注释为一个字读元组是一个很好的默认。这一点很重要，因为带有 <code>const</code> 的断言的数组字面量将被推断为只读元组类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = [<span class="number">3</span>, <span class="number">4</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">[x, y]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(x * x + y * y); <span class="comment">// error 因为不能保证元组不被修改，所以错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">distance(point);</span><br></pre></td></tr></table></figure></li></ol><h2 id="类型操纵">类型操纵</h2><ol><li>从类型中创建类型，<code>ts</code> 允许用其他类型的术语来表达类型</li><li>实际上有各种各样的类型操作符可以使用。也可以用我们已经有的值来表达类型</li><li>通过结合各种类型操作符，我们可以用一种简洁，可维护的方式来表达复杂的操作和值<ul><li>泛型型 - 带参数的类型</li><li><code>Keyof</code> 类型操作符 - <code>keyof</code> 操作符创建新类型</li><li><code>Typeof</code> 类型操作符 - 使用 <code>typeof</code> 操作符来创建新的类型</li><li>索引访问类型 - 使用 <code>Type[&quot;a&quot;]</code> 语法来访问一个类型的子集</li><li>条件类型 - 在类型系统中像 <code>if</code> 语句一样行事的类型</li><li>映射类型 - 通过映射现有类型中的每个属性来创建类型</li><li>模版字面面类型 - 通过模版字面字符串改变属性的映射类型</li></ul></li></ol><h3 id="泛型">泛型</h3><ol><li>在函数泛型已经介绍了泛型可以指定类型参数或者由 <code>TS</code> 进行推断</li></ol><h4 id="通用类型变量">通用类型变量</h4><ol><li><p>当我们使用泛型时，编译器会强制要求在函数主体中正确使用泛型参数，也就是说，实际上把这些参数当作是任何和所有的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length); <span class="comment">// error 不一定有 length 这个变量</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="泛型类型">泛型类型</h4><ol><li><p>泛型函数的类型与非泛型函数的类型一样，类型参数列在前面，与函数声明类似</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = identity;</span><br></pre></td></tr></table></figure></li></ol><h4 id="泛型类">泛型类</h4><p>一个泛型类的形状与泛型接口相似。泛型类在类的名字后面有一个 <code>&lt;&gt;</code> 中的泛型参数列表</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">NumType</span>&gt; </span>&#123;</span><br><span class="line">    zeroValue: NumType;</span><br><span class="line">    add: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> NumType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和接口一样，把类型参数放在类本身，可以让我们确保类的所有属性都与相同的类型一起工作</p><p>一个类的类型有两个方面：静态方面和实例方面。通用类只在其实例而非静态侧具有通用性，所有在使用类时，静态成员不能使用类的类型参数</p><h4 id="泛型约束">泛型约束</h4><ol><li>我们希望限制这个函数 <code>any</code> 和所有类型一起工作，而不是与 <code>any</code> 和所有同时具有 <code>.length</code> 属性的类型一起工作。只要这个类型有这个成员，我们就允许它，但它必须至少有这个成员。必须把我们的要求作为一个约束条件列在 <code>Type</code> 可以是什么</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(&#123; <span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="在泛型约束中使用类型参数">在泛型约束中使用类型参数</h4><p>可以声明一个受另一个类型参数约束的类型参数。例如，在这里我们想从一个给定名称的对象中获取一个属性。我们想确保我们不会意外地获取一个不存在 <code>obj</code> 上的属性，所以我们要在这两种类型之间放置一个约束条件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">getProperty(x, <span class="string">&quot;m&quot;</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h4 id="在泛型中使用类类型">在泛型中使用类类型</h4><p>在 <code>TS</code> 中使用泛型创建工厂时，有必要通过其构造函数来引用类的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params">c: &#123; <span class="keyword">new</span> (): T &#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个更高级的例子，使用原型属性来推断和约束类型的构造函数和实例之间的关系</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beekeeper</span> </span>&#123;</span><br><span class="line">    hasMask: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooKeeper</span> </span>&#123;</span><br><span class="line">    nametag: <span class="built_in">string</span> = <span class="string">&quot;Mikle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    numLegs: <span class="built_in">number</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bee</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    keeper: Beekeeper = <span class="keyword">new</span> Beekeeper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    keeper: ZooKeeper = <span class="keyword">new</span> ZooKeeper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Animal</span>&gt;(<span class="params">c : &#123; <span class="keyword">new</span> (): A &#125; </span>): <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;</span><br><span class="line">createInstance(Bee).keeper.hasMask;</span><br></pre></td></tr></table></figure><h3 id="keyof-类型操作符"><code>keyof</code> 类型操作符</h3><p><code>keyof</code> 运算符接收一个对象类型，其产生其键的字符串或数字字面联合</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; y: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> P = keyof Point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: P = <span class="string">&quot;x&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> p2: P = <span class="string">&quot;y&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> p3: P = <span class="string">&quot;z&quot;</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>如果该类型有一个字符串或数字索引签名，<code>keyof</code> 将返回这些类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Arrayish = &#123; [n: <span class="built_in">number</span>]: unknown &#125;;</span><br><span class="line"><span class="keyword">type</span> A = keyof Arrayish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> a1: A = <span class="string">&quot;0&quot;</span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mapish = &#123; [k: <span class="built_in">string</span>]: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> M = keyof Mapish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m: M = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> m2: M = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> m3: M = <span class="literal">true</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>注意上面这个例子中，<code>M</code> 是 <code>string | number</code> – 这是因为 <code>JavaScript</code> 对象的键总是被强制为字符串，所以 <code>obj[0]</code> 总是和 <code>obj['0']</code> 相同</p><p><code>keyof</code> 类型在与映射类型结合时变得特别有用</p><h3 id="Typeof-类型操作符"><code>Typeof</code> 类型操作符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="keyword">typeof</span> s;</span><br><span class="line"></span><br><span class="line">n = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">n = <span class="number">100</span>; <span class="comment">// error 不能将 number 分配给 string</span></span><br></pre></td></tr></table></figure><p><code>typeof</code> 对基本类型来说不是很有用，但结合其他类型操作符，可以使用 <code>typeof</code> 方便的表达许多模式。</p><p>这里介绍一个预定义的类型 <code>ReturnType&lt;T&gt;</code> 它接受一个函数类型并产生其返回类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Predicate = <span class="function">(<span class="params">x: unknown</span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> K = ReturnType&lt;Predicate&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们试图在一个函数名上使用 ReturnType 会发生错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">3</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请记住 值和类型不是一回事，为了指代值 f 的类型，我们使用 typeof</span></span><br><span class="line"><span class="keyword">type</span> P = ReturnType&lt;f&gt;; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P = ReturnType&lt;<span class="keyword">typeof</span> f&gt;; <span class="comment">// &#123; x: number; y: number;&#125;</span></span><br></pre></td></tr></table></figure><p><code>ts</code> 故意限制了可以使用 <code>typeof</code> 表达式的种类，具体来说，只有在标识符或其属性上使用 <code>typeof</code> 是合法的，这有助于避免混乱的陷阱</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shouldContinue: <span class="keyword">typeof</span> msgbox(<span class="string">&quot;helelo&quot;</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="索引访问类型">索引访问类型</h3><p>我们可以使用索引访问类型来查询另一个类型上的特定属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123; <span class="attr">age</span>: <span class="built_in">number</span>; name: <span class="built_in">string</span>; alive: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> Age = Person[<span class="string">&quot;age&quot;</span>]; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ag1: Age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ag2: Age = <span class="string">&quot;11&quot;</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>索引类型本身就是一个类型，所以我们可以完全使用 <code>unions</code> <code>keyof</code> 或其他类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    alive: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I1 = Person[<span class="string">&quot;age&quot;</span> | <span class="string">&quot;name&quot;</span>]; <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i1: I1 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> i2: I1 = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I2 = Person[keyof Person]; <span class="comment">// string | number | boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i3: I2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> i4: I2 = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> i5: I2 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>如果试图索引一个不存在的属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I1 = Person[<span class="string">&quot;alve&quot;</span>]; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>另一种使用任意类型进行索引的例子是使用 <code>number</code> 来获取一个数组元素的类型，我们可以把它和 <code>typeof</code> 结合起来，方便地获取一个数组字面的元素类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyArray = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;Eve&quot;</span>, <span class="attr">age</span>: <span class="number">38</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person = <span class="keyword">typeof</span> MyArray[<span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: Person = &#123;</span><br><span class="line">    name: <span class="string">&quot;suxi&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Age = <span class="keyword">typeof</span> MyArray[<span class="built_in">number</span>][<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> age1: Age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Age2 = Person[<span class="string">&quot;age&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age2: Age2 = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>只能在索引时使用类型，这意味着不能使用 <code>const</code> 来做一个变量引用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> Age = Person[key]; <span class="comment">// error // key 在这里用作值而不是类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> Age = Person[key];</span><br></pre></td></tr></table></figure><h3 id="条件类型">条件类型</h3><ol><li><p>在大多数有用的程序的核心，我们必须根据输入来做决定 <code>JS</code> 也不例外，但鉴于数值可以很容易地被内省，这些决定也是基于输入的类型。条件类型有助于描述输入和输出的类型之间的关系</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    live(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    woof(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> Example1 = Dog <span class="keyword">extends</span> Animal ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> Example2 = <span class="built_in">RegExp</span> <span class="keyword">extends</span> Animal ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件类型的形式看起来像是 js 中的条件表达式</span></span><br><span class="line">SomeType <span class="keyword">extends</span> OtherType ? TrueType : FalseType;</span><br><span class="line"><span class="comment">// 当 extends 左边的类型可以赋值给右边的类型时，那么你将得到第一个分支中的类型，否则得到后一个分支中的类型</span></span><br><span class="line"><span class="comment">// 当然上面这个例子看起来并不是显得有用，因为一眼就可以看出来它的类型。但条件类型的威力来自于它所带来的好处，条件类型的力量来自于它们与泛型一起使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IdLabel &#123;</span><br><span class="line">    id: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NameLabel &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>(<span class="params">id: <span class="built_in">number</span></span>): <span class="title">IdLabel</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">NameLabel</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>(<span class="params">nameOrId: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">IdLabel</span> | <span class="title">NameLabel</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>(<span class="params">nameOrId: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">IdLabel</span> | <span class="title">NameLabel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;unimplemented&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>createLabel</code> 的这些重载描述了一个单一的 <code>js</code> 函数，该函数根据其输入的类型作出选择。注意一些事情：</p><ul><li>如果一个库必须在其 <code>API</code> 中反复作出同样的选择，这就会变得很麻烦</li><li>必须创建三个重载：一个用于确定类型的情况，一个用于最一般的情况，对于 <code>createLabel</code> 所能处理的每一种新类型，重载的数量都会呈指数级增长</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NameOrId&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span> ? IdLabel : NameLabel;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLabel</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">number</span> | <span class="title">string</span>&gt;(<span class="params">idOrName: T</span>): <span class="title">NameOrId</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;unimplemented&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = createLabel(<span class="string">&quot;typescript&quot;</span>);</span><br><span class="line"><span class="comment">// a: NameLabel</span></span><br><span class="line"><span class="keyword">let</span> b = createLabel(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// b: IdLabel</span></span><br><span class="line"><span class="keyword">let</span> c = createLabel(<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">&quot;hello&quot;</span> : <span class="number">42</span>);</span><br><span class="line"><span class="comment">// c: NameLabel | IdLabel</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="条件类型约束">条件类型约束</h4><ol><li><p>条件类型中的检查会给我们提供一些新的信息。就像用类型守卫缩小范围可以给我们一个更具体的类型一样，条件类型的真正分支将通过我们检查的类型进一步约束泛型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Message&lt;T&gt; = T[<span class="string">&quot;message&quot;</span>]; <span class="comment">// error 类型 message 无法用于索引类型 T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MessageOf&lt;T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: unknown &#125;&gt; = T[<span class="string">&quot;message&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Email &#123;</span><br><span class="line">    message: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EmailMessageContents = MessageOf&lt;Email&gt;;</span><br></pre></td></tr></table></figure></li><li><p>然而，如果我们想要让 <code>MessageOf</code> 接受任何类型，并在消息属性不可用的情况下，默认为 <code>never</code> 类型呢，我们可以通过约束条件移出，并引入一个条件类型来做到这一点</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MessageOf&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: unknown &#125; ? T[message] : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> Dog = &#123;</span><br><span class="line">    bark(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> DogMessageContents = MessageOf&lt;Dog&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dmc: DogMessageContents = <span class="string">&quot;error&quot;</span> <span class="keyword">as</span> <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure></li><li><p>在真正的分支中，<code>TS</code> 会知道 <code>T</code> 会有一个消息属性。下面也有一个例子，将数组类型平铺到它们的元素类型上，但在其他方面不做处理</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 Flatten 被赋予一个数组类型时，它使用一个带有数字的索引访问来获取 string[] 的元素类型。否则，它只是返回它被赋予的类型</span></span><br><span class="line"><span class="keyword">type</span> Flatten&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span>[] ? T[<span class="built_in">number</span>] : T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Str = Flatten&lt;<span class="built_in">string</span>[]&gt;;</span><br><span class="line"><span class="keyword">type</span> Num = Flatten&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str1: Str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num: Num = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li></ol><h4 id="在条件类型内进行推理">在条件类型内进行推理</h4><ol><li><p>我们只是发现自己使用条件类型来应用约束条件，然后提取出类型，这最终成为一种常见的操作，而条件类型使得它变得更容易</p></li><li><p>条件类型为我们提供了一种方法来推断在真实分支中使用 <code>infer</code> 关键字进行对比的类型。例如，我们可以在 <code>Flatten</code> 中推断出元素类型，而不是用索引访问类型手动提取出来</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flatten&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;infer Item&gt; ? Item : T;</span><br></pre></td></tr></table></figure></li><li><p>上面的例子，我们使用 <code>infer</code> 关键字来声明性地引入一个名为 <code>Item</code> 的新的通用类型变量，而不是指定如何在真实分支中检索 <code>T</code> 的元素类型，这使得我们不必考虑如何挖掘和探测我们感兴趣的类型的结构</p></li><li><p>我们可以使用 <code>infer</code> 关键字编写一些有用的辅助类型别名，例如，对于简单的情况，我们可以从函数类型中提取出返回类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">never</span>[]) =&gt; infer Return ? Return : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Num = GetReturnType&lt;<span class="function">() =&gt;</span> <span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> Str = GetReturnType&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> Bool = GetReturnType&lt;<span class="function">() =&gt;</span> <span class="built_in">boolean</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Never = GetReturnType&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure></li><li><p>当从一个具有多个调用签名的类型(如重载函数的类型)进行推断时，从最后一个签名进行推断(据推测，这是最容许的万能情况)，不可能根据参数类型的列表来执行重载解析</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">stringOrNum</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">stringOrNum</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">stringOrNum</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> | <span class="title">number</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 = ReturnType&lt;<span class="keyword">typeof</span> stringOrNum&gt;; <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="分布式条件类型">分布式条件类型</h4><ol><li><p>当条件类型作用于一个通用类型时，当给定一个联合类型时，它们就变成了分布式的。例如，以下面的例子为例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ToArray&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span> ? T[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果我们将一个联合类型插入 ToArray, 那么条件类型被用于该联合的每个成员</span></span><br><span class="line"><span class="keyword">type</span> StrArrOrNumber = ToArray&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="comment">// string[] | number[] 这就是分布式 它的结果不是 (string | number)[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> 这里发生的情况是，StrArrOrNumArr 分布在</span></span><br><span class="line"><span class="comment"> string | number;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 并对每个联合的每个成员类型进行映射，以达到有效的目的</span></span><br><span class="line"><span class="comment"> ToArray&lt;string&gt; | ToArray&lt;number&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 给我们留下了</span></span><br><span class="line"><span class="comment"> string[] | number[]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 通常情况下，分布性是需要的行为，为了避免这种行为，你可以使用方括号包围 extends 关键字的每一边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ToArrayNonDist&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">any</span>] ? T[] : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> StrArrOrNumArr = ToArrayNonDist&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;; <span class="comment">// 现在是 (string | number)[]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="映射类型">映射类型</h3><ol><li><p>当不想重复定义类型，一个类型可以以另一个类型为基础创建新类型</p></li><li><p>映射类型建立在索引签名的语法上，索引签名用于声明没有被提前声明的属性类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OnlyBoolsAndNumber = &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">boolean</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> confirms: OnlyBoolsAndNumber = &#123;</span><br><span class="line">    del: <span class="literal">true</span>,</span><br><span class="line">    rodney: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 映射类型是一种通用类型，它使用 propertyKeys 的联合，经常通过 keyof 创建 迭代键来创建一个类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionsFlags&lt;T&gt; = &#123;</span><br><span class="line">    [Property <span class="keyword">in</span> keyof T]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FeatureFlags = &#123;</span><br><span class="line">    darkMode: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    newUserProfile: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">type FeatureOptions = &#123;</span></span><br><span class="line"><span class="comment">    darkMode: boolean;</span></span><br><span class="line"><span class="comment">    newUserProfile: boolean;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FeatureOptions = OptionsFlags&lt;FeatureFlags&gt;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="映射修改器">映射修改器</h4><ol><li><p>在映射的过程中，有两个额外的修饰可以应用: <code>readonly</code> 和 <code>?</code> 它们分别影响可变性和可选性</p></li><li><p>可以通过 <code>-</code> 或 <code>+</code> 作为前缀来删除或添加这些修饰语。如果不加前缀，那么假定是 <code>+</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CreateMutable&lt;T&gt; = &#123;</span><br><span class="line">    -<span class="keyword">readonly</span> [Property <span class="keyword">in</span> keyof T]: T[Property];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LockedAccount = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> id: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnlockedAccount = CreateMutable&lt;LockedAccount&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Concrete&lt;T&gt; = &#123;</span><br><span class="line">    [Property <span class="keyword">in</span> keyof T]-?: T[Property];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MaybeUser = &#123;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User = Concrete&lt;MaybeUser&gt;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="通过-as-做-key-重映射">通过 <code>as</code> 做 <code>key</code> 重映射</h4><ol><li><p>可以通过映射类型中的 <code>as</code> 子句重新映射映射类型中的键</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">type</span> MappedTypeWithNewProperties&lt;T&gt; = &#123;</span><br><span class="line">    [Property <span class="keyword">in</span> keyof T <span class="keyword">as</span> NewKeyType]: T[Property];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用模版字面类型等功能，从先前的属性名称中创建一个新的属性名称</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Capitalize ts提供的模版字符串类型 泛型传入 字符串类型 转换第一个字符大写其余部分不变</span></span><br><span class="line"><span class="comment">// string &amp; Property 是为了确保 Property 是一个字符串类型 交集 暂时这么理解</span></span><br><span class="line"><span class="keyword">type</span> Getter&lt;T&gt; = &#123;</span><br><span class="line">    [Property <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;<span class="built_in">string</span> &amp; Property&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> T[Property];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    location: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LazyPerson = Getter&lt;Person&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lazyPerson: LazyPerson = &#123;</span><br><span class="line">    getName: <span class="function">() =&gt;</span> <span class="string">&quot;suxi&quot;</span>,</span><br><span class="line">    getAge: <span class="function">() =&gt;</span> <span class="number">18</span>,</span><br><span class="line">    getLocation: <span class="function">() =&gt;</span> <span class="string">&quot;beijing&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>过滤掉某些属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exclude&lt;U, V&gt; U类型和V类型相同时返回null类型</span></span><br><span class="line"><span class="keyword">type</span> RemoveKindField&lt;T&gt; = &#123;</span><br><span class="line">    [Property <span class="keyword">in</span> keyof T <span class="keyword">as</span> Exclude&lt;Property, <span class="string">&quot;kind&quot;</span>&gt;]: T[Property];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> KindlessCircle = RemoveKindField&lt;Circle&gt;;</span><br></pre></td></tr></table></figure></li><li><p>可以映射任意的联合体，不仅仅是 <code>string | number | symbol</code> 的联合体，还可以是任何类型的联合体</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in 操作符 E 类型 是否在联合类型 Events 内</span></span><br><span class="line"><span class="keyword">type</span> EventConfig&lt;Events <span class="keyword">extends</span> &#123; <span class="attr">kind</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">    [E <span class="keyword">in</span> Events <span class="keyword">as</span> E[<span class="string">&quot;kind&quot;</span>]]: <span class="function">(<span class="params">event: E</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SquareEvent = &#123;</span><br><span class="line">    kind: <span class="string">&quot;square&quot;</span>,</span><br><span class="line">    x: <span class="built_in">number</span>,</span><br><span class="line">    y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> CircleEvent = &#123;</span><br><span class="line">    kind: <span class="string">&quot;circle&quot;</span>,</span><br><span class="line">    radius: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config = EventConfig&lt;SquareEvent | CircleEvent&gt;;</span><br></pre></td></tr></table></figure></li><li><p>映射类型与本类型操作部分的其他功能配合得很好，例如，这里有一个使用条件类型的映射类型，它根据一个对象的属性 <code>pii</code> 是否被设置为字面意义上的 <code>true</code> 返回 <code>true</code> 或 <code>false</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ExtractPII&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]: T[P] <span class="keyword">extends</span> &#123; <span class="attr">pii</span>: <span class="literal">true</span> &#125; ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DBFields = &#123;</span><br><span class="line">    id: &#123; <span class="attr">format</span>: <span class="string">&quot;incrementing&quot;</span> &#125;;</span><br><span class="line">    name: &#123; <span class="attr">type</span>: <span class="built_in">string</span>; pii: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectsNeedingGDPRDeletion 是 &#123; id: false; name: true; &#125;</span></span><br><span class="line"><span class="keyword">type</span> ObjectsNeedingGDPRDeletion = ExtractPII&lt;DBFields&gt;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="类">类</h2><h3 id="类成员">类成员</h3><h4 id="类型属性的类型">类型属性的类型</h4><ol><li><p>在一个类上声明字段，创建一个公共的可写属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pt = <span class="keyword">new</span> Point();</span><br><span class="line">pt.x = <span class="number">0</span>;</span><br><span class="line">pt.y = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>和其他位置一样，类型注解是可选的，但如果不指定，将是一个隐含的 <code>any</code> 类型</p></li><li><p>字段也可以有初始化器，这些初始化器将在类被实例化时自动运行</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pt = <span class="keyword">new</span> Point();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;pt.x&#125;</span>, <span class="subst">$&#123;pt.y&#125;</span>`</span>)</span><br></pre></td></tr></table></figure></li><li><p>和 <code>const</code> <code>let</code> <code>var</code> 一样，一个类属性的初始化器将被用来推断其类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pt = <span class="keyword">new</span> Point();</span><br><span class="line">pt.x = <span class="string">&quot;0&quot;</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p><code>tsconfig.json</code> 中 <code>strictPropertyInitialization</code> 设置控制是否需要在构造函数中初始化实例字段</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置了 strictPropertyInitialization 为 true 需要在 构造函数中 初始化 字段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodGreeter</span> </span>&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是注意，字段需要在构造函数本身中初始化。<code>TypeScript</code> 不会分析从构造函数中调用的方法来检测初始化，因为派生类可能会覆盖这些方法而无法初始化成员</p></li><li><p>如果打算通过构造函数以外的方式来确定初始化一个字段(例如，也许一个外部库为你填充了你的类的一部分)，可以使用确定的赋值断言操作符 <code>!</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有初始化，但没有报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OKGreeter</span> </span>&#123;</span><br><span class="line">    name!: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="readonly"><code>readonly</code></h4><ol><li><p>字段的前缀可以是 <code>readonly</code> 修饰符。这可以防止在构造函数之外对该字段进行赋值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">readonly</span> name: <span class="built_in">string</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">othername?: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (othername !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = othername;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">err</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;not ok&quot;</span>; <span class="comment">// error 不能在 constructor 以外的地方赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> Greeter();</span><br><span class="line">g.name = <span class="string">&quot;also not ok&quot;</span> <span class="comment">// error 不能在 constructor 以外的地方赋值</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="构造器">构造器</h4><ol><li><p>类构造函数与函数非常相似。可以添加带有类型注释的参数、默认值和重载</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带默认值的正常签名</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">s: <span class="built_in">string</span></span>);</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">xs: <span class="built_in">any</span>, y?: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类的构造函数签名和函数签名之间只有一些区别</p><ul><li>构造函数不能有类型参数 - 这属于外层类的声明</li><li>构造函数不能有返回类型注释 - 类的实例总是被返回</li></ul></li><li><p><code>super</code> 调用</p><ul><li>和 <code>js</code> 一样，如果你有一个基类，在使用任何 <code>this.</code> 成员之前，需要在构造器主体中调用 <code>super</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    k = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 在 ES5 中打印一个错误的值，在 ES6 中抛出异常</span></span><br><span class="line">        <span class="comment">// 必须在访问派生类的 this 前调用 super</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.k);</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="方法">方法</h4><ol><li><p>一个类上的函数属性被称为方法，方法可以使用函数和构造函数相同的所有类型注释</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    scale(n: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x *= n;</span><br><span class="line">        <span class="built_in">this</span>.y *= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>除了标准的类型注解，<code>ts</code> 并没有为方法添加其他新的东西</p></li><li><p>注意，在一个方法体中，仍然必须通过 <code>this</code> 访问字段和其他方法，方法体中的非限定名称将总是指代包围范围内的东西</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    x: <span class="built_in">string</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        x = <span class="string">&quot;world&quot;</span>; <span class="comment">// error 修改的是 第一行的 x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Getters-Setters"><code>Getters</code> / <code>Setters</code></h4><ol><li><p>类也可以有访问器</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    _length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">length</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">length</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._length = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意，一个没有额外逻辑的字段支持的 <code>get/set</code> 对在 <code>js</code> 中很少有用，如果不需要在 <code>get/set</code> 操作中添加额外的逻辑，暴露公共字段也是可以的</p></li><li><p><code>TypeScript</code> 对访问器有一些特殊的推理规则</p><ul><li>如果存在 <code>get</code> 但没有 <code>set</code>，则该属性自动是只读的</li><li>如果没有指定 <code>setter</code> 参数的类型，它将从 <code>getter</code> 的返回类型中推断出来</li><li>访问器和设置器必须有相同的成员可见性</li></ul></li><li><p>从 <code>TypeScript4.3</code> 开始，可以有不同类型的访问器用于获取和设置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">size</span>(): <span class="title">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">size</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="built_in">Number</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isFinite(num)) &#123;</span><br><span class="line">            <span class="built_in">this</span>._size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>._size = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="索引签名-2">索引签名</h4><p>类可以声明索引签名；这些签名的作用与其他对象类型的索引签名相同</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    [s: <span class="built_in">string</span>]: <span class="built_in">boolean</span> | (<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">boolean</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">check</span>(<span class="params">s: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>[s] <span class="keyword">as</span> <span class="built_in">boolean</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为索引签名类型需要同时捕获方法和属性，所以要有用地使用这些类型并不容易。一般来说，最好将索引数据存储在另一个地方，而不是类实例本身</p><h3 id="类继承">类继承</h3><h4 id="implements-子句"><code>implements</code> 子句</h4><ol><li><p>可以使用一个 <code>implements</code> 子句来检查一个类，是否满足一个特定的接口，如果一个类不能正确地实现它，就会发出一个错误</p></li><li><p>类可以实现多个接口，例如 <code>class C implements A, B &#123;&#125;</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Pingable &#123;</span><br><span class="line">    ping(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sonar</span> <span class="title">implements</span> <span class="title">Pingable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">ping</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;ping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="title">implements</span> <span class="title">Pingable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缺少 ping 方法</span></span><br><span class="line">    <span class="function"><span class="title">pong</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;pong!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意，<code>implements</code> 子句只是检查类是否可以被当作接口类型来对待，它根本不会改变类的类型或其方法。一个常见的错误来源是认为 <code>implements</code> 子句会改变类的类型 - 它不会! 它不会!</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个错误的例子</span></span><br><span class="line"><span class="keyword">interface</span> Checkable &#123;</span><br><span class="line">    check(name: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameChecker</span> <span class="title">implements</span> <span class="title">Checkable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// s 隐式是 any 类型</span></span><br><span class="line">    <span class="comment">// 我们可能期许它的类型会受到 check 的 name: string 参数的影响</span></span><br><span class="line">    <span class="comment">// 但事实并非如此，实现子句并没有改变类主体的检查方式或其类型的推断</span></span><br><span class="line">    <span class="function"><span class="title">check</span>(<span class="params">s</span>)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> s.toLowercase() === <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样的，实现一个带有可选属性的接口并不能创建该属性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="title">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.y = <span class="number">10</span>; <span class="comment">// 类型C上不存在属性 y</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="extends-子句"><code>extends</code> 子句</h4><ol><li><p>类可以从基类中扩展出来，派生类拥有其基类的所有属性和方法，也可以定义额外的成员</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;moving along!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">woof</span>(<span class="params">times: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;woof&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">d.move();</span><br><span class="line">d.woof(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="重写方法">重写方法</h4><ol><li><p>派生类也可以覆盖基类的一个字段或属性，可以使用 <code>super.</code> 语法来访问基类方法。注意，因为 <code>JavaScript</code> 类是一个简单的查找对象，没有超级字段的概念</p></li><li><p><code>TypeScript</code> 强制要求派生类总是其基类的一个子类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">greet</span>(<span class="params">name?: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>.greet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`hello, <span class="subst">$&#123;name.toUpperCase()&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> Derived();</span><br><span class="line">d.greet();</span><br><span class="line">d.greet(<span class="string">&quot;reader&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>派生类遵循其基类契约是很重要的，通过基类引用派生类实例是非常常见的(而且总是合法的)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b: Base = d;</span><br><span class="line">b.greet();</span><br></pre></td></tr></table></figure></li><li><p>如果遵循基类的约定将会报错</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">greet</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 必须的参数，报错</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello，&quot;</span> + name.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="初始化顺序">初始化顺序</h4><ol><li>类初始化的顺序是:<ul><li>基类的字段被初始化</li><li>基类构造函数运行</li><li>派生类的字段被初始化</li><li>派生类构造函数运行</li></ul></li><li>这个顺序意味着基类构造函数在自己的构造函数中看到自己的属性，因为派生类的字段初始化还没有运行</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&quot;base&quot;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;my name is&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&quot;derived&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> Derived();</span><br></pre></td></tr></table></figure><h4 id="继承内置类型">继承内置类型</h4><div class="tip cogs"><p>注意: 如果不打算继承 <code>Array</code> <code>Error</code> <code>Map</code> 等内置类型，或者编译目标明确设置为 <code>es6/es2015</code> 或以上，则不需要关注</p></div><ol><li><p>在 <code>es2015</code> 中，返回对象的构造函数隐含地替代了 <code>super(...)</code> 的任何调用者的 <code>this</code> 的值，生成的构造函数代码有必要捕获 <code>super(...)</code> 的任何潜在返回并将其替换为 <code>this</code></p></li><li><p>因此，子类化 <code>Error</code> <code>Array</code> 等可能不再像预期那样工作。这是由于 <code>Error</code> <code>Array</code> 等的构造函数使用 <code>ECMAScript6</code> 的 <code>new.target</code> 来调整原型链；然而，在 <code>ECMAScript 5</code> 中调用构造函数时，没有办法确保 <code>new.target</code> 的值。其他的下级编译器一般默认有同样的限制</p></li><li><p>对于下面的子类 有以下问题</p><ul><li>方法在构造这些子类所返回的对象上可能是未定义的，所以调用 <code>sayHello</code> 会导致错误</li><li><code>instanceof</code> 将在子类的实例和它们的实例之间被打破，所以 <code>new MsgError() instanceof MsgError</code> 将返回 <code>false</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="built_in">this</span>.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> msgError = <span class="keyword">new</span> MsgError(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msgError.sayHello()); <span class="comment">// TypeError msgError.sayHello is not a function</span></span><br></pre></td></tr></table></figure><ul><li>作为建议，可以在任何 <code>super</code> 调用后立即手动调整原型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(m);</span><br><span class="line">        <span class="built_in">Object</span>.setPrototypeOf(<span class="built_in">this</span>, MsgError.prototype);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        cosnole.log(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="成员的可见性">成员的可见性</h3><h4 id="public"><code>public</code></h4><ol><li>类成员的默认可见性是公共的，一个公共成员可以在任何地方被访问</li><li><code>public</code> 是默认的可见性修饰符，所以永远不需要在类成员上书写它，除非为了风格/可读性的原因</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> Greeter();</span><br><span class="line">g.greet();</span><br></pre></td></tr></table></figure><h4 id="protected"><code>protected</code></h4><ol><li><p>受保护的 <code>protected</code> 成员只对它们所声明的类或子类可见</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hello &quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialGreeter</span> <span class="keyword">extends</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">howdy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;howdy &quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> SpecialGreeter();</span><br><span class="line">g.greet();</span><br><span class="line">g.getName(); <span class="comment">// 无权访问</span></span><br></pre></td></tr></table></figure></li><li><p>受保护成员的暴露</p><ul><li>派生类需要遵循它们的基类契约，但可以选择公开具有更多能力的基类的子类型，这包括将受保护的成员变成公开</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> m = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    m = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> Derived();</span><br><span class="line"><span class="built_in">console</span>.log(d.m); <span class="comment">// 没有问题</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="private"><code>private</code></h4><ol><li><p><code>private</code> 和 <code>protected</code> 一样，但不允许从子类中访问该成员</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> Base();</span><br><span class="line"><span class="built_in">console</span>.log(b.x); <span class="comment">// 不能类外访问</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dervied</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">showX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// 不能在子类访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>私有成员对于派生类是不可见的，所以派生类不能增加其可见性</p></li><li><p>跨实例的私有访问 <code>TS</code> 允许跨实例私有访问</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">sameAs</span>(<span class="params">other: A</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> other.x === <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>像 <code>TS</code> 类型系统的其他方面一样，<code>private</code> 和 <code>protected</code> 只在类型检查中被强制执行</p></li><li><p>这意味着 <code>JS</code> 的运行时结构，如 <code>in</code> 或简单的属性查询，仍然可以访问一个私有或保护的成员</p></li><li><p><code>private</code> 也允许在类型检查时使用括号符号进行访问，这使得私有声明的字段更容易被单元测试之类的东西所访问，缺点是这些字段是软性私有的，不能严格执行私有特性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> secretKey = <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> MySafe();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s.secretKey); <span class="comment">// error</span></span><br><span class="line"><span class="built_in">console</span>.log(s[<span class="string">&quot;secretKey&quot;</span>]); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li><li><p>与 <code>TS</code> 的 <code>private</code> 不同，<code>JS</code> 的 <code>private</code> 字段 <code>#</code> 在编译后仍然是 <code>private</code> 的，并且不提供前面提到的像括号符号访问那样的窗口，使其成为 <code>private</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    #barkAmount = <span class="number">0</span>;</span><br><span class="line">    personality = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.#barkAmount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="built_in">console</span>.log(dog.#barkAmount); <span class="comment">// error </span></span><br><span class="line"><span class="built_in">console</span>.log(dog[<span class="string">&quot;#barkAmount&quot;</span>]) <span class="comment">// error // 即便编译成功也是 undefined</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="静态成员">静态成员</h3><ol><li>类可以有静态成员，这些成员并不与类的特定实例相关联。它们可以通过类的构造函数对象本身来访问</li><li>静态成员也可以使用相同的 <code>public</code> <code>protected</code> 和 <code>private</code> 可见性修饰符</li><li>静态成员也会被继承</li><li>和 <code>JS</code> 一样，静态方法中的 <code>this</code> 代表类本身</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> xx = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">printX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(MyClass.x);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// this表示 MyClass 类本身</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">printXX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.xx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MyClass.x);</span><br><span class="line">MyClass.printX();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MyClass.xx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getGreeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    myGreeting = Derived.getGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特殊的静态名称">特殊的静态名称</h4><ol><li>一般来说，从函数原型覆盖属性是不安全/不可能的，因为类本身就是可以用 <code>new</code> 调用函数，所以某些静态名称不能使用。像 <code>name</code> <code>length</code> 和 <code>call</code> 这样的函数属性，定义为静态成员是无效的</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">&quot;S!&quot;</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类里的-static-区块">类里的 <code>static</code> 区块</h3><ol><li>静态块允许写一串有自己作用域的语句，可以访问包含类中的私有字段，这意味着我们可以用写语句的所有能力来写初始化代码，不泄露变量，并能完全访问我们类的内部结构</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> #count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">count</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> Foo.#count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> lastInstances = &#123;</span><br><span class="line">                length: <span class="number">100</span></span><br><span class="line">            &#125;;</span><br><span class="line">            Foo.#count += lastInstances.length;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型类-2">泛型类</h3><p>类，和接口一样，可以是泛型的。当一个泛型类用 <code>new</code> 实例化时，其类型参数的推断方式与函数调用的方式相同</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    contents: T;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value: T</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.contents = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> Box(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li>类可以像接口一样使用通用约束和默认值<ul><li>静态成员不能引用类的类型参数，因为类型总是被完全擦除的</li><li>一个泛型类的静态成员永远不能引用该类的类型参数</li></ul></li></ol><h3 id="类运行时的-this">类运行时的 <code>this</code></h3><ol><li><p>记住，<code>TypeScript</code> 并没有改变 <code>JavaScript</code> 的运行时行为，而 <code>JavaScript</code> 的运行时行为偶尔很奇怪</p></li><li><p>比如，<code>JavaScript</code> 对这一点的处理确实是不寻常的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">    getName: c.getName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">// 输出 obj 而不是 MyClass</span></span><br></pre></td></tr></table></figure></li><li><p>默认情况下，函数内 <code>this</code> 的值取决于函数的调用方式，在这个例子中，因为函数是通过 <code>obj</code> 引用调用，所以它的 <code>this</code> 值是 <code>obj</code> 而不是类实例，这很少是希望发生的事情，<code>TS</code> 提供了一些方法来减轻或防止这种错误</p></li><li><p>箭头函数</p><ul><li>如果有一个经常被调用的函数，失去它的 <code>this</code> 上下文，那么使用一个箭头函数而不是方法定义是有意义的</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line"></span><br><span class="line">    getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="keyword">const</span> g = c.getName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// myClass</span></span><br></pre></td></tr></table></figure></li><li><p>关于箭头函数，还有一些权衡</p><ul><li><code>this</code> 值保证在运行时是正确的，即使是没有经过 <code>TypeScript</code> 检查的代码也是如此</li><li>这将使用更多的内存，因为每个类实例都将有它自己的副本，每个函数都是这样定义的</li><li>不能在派生类中使用 <code>super.getName</code>，因为在原型链中没有入口可以获取基类方法</li></ul></li><li><p><code>this</code> 参数出现在所有其他参数之后</p><ul><li>在方法或函数定义中，一个名为 <code>this</code> 的初始化参数在 <code>TypeScript</code> 中具有特殊的意义。这些参数在编译过程中会被删除</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"><span class="built_in">this</span>: SomeType, x: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>TS</code> 检查调用带有 <code>this</code> 参数的函数，是否正确的上下文中进行，我们可以不使用箭头函数，而是在定义方法中添加一个 <code>this</code> 参数，以静态地确保方法被正确调用</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"><span class="built_in">this</span>: MyClass</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">c.getName(); <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = c.getName;</span><br><span class="line"><span class="built_in">console</span>.log(g());</span><br></pre></td></tr></table></figure><ul><li>这种方法做出了与箭头函数方法相反的取舍<ul><li><code>JS</code> 调用者仍然可能在不知不觉中错误地使用类方法</li><li>每个类定义只有一个函数被分配，而不是每个类实例一个函数</li><li>基类方法定义仍然可以通过 <code>super</code> 调用</li></ul></li></ul></li></ol><h3 id="this-类型"><code>this</code> 类型</h3><ol><li><p>在类中，一个叫做 <code>this</code> 的特殊类型动态地指向当前类的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    contents: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.contents = value;</span><br><span class="line">        <span class="comment">// 在这里推断出 set 返回的类型是 this，而不是Box</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClearbleBox</span> <span class="keyword">extends</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.contents = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> ClearbleBox();</span><br><span class="line"><span class="keyword">const</span> b = a.set(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure></li><li><p>也可以在参数类型注释中使用 <code>this</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    content: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sameAs</span>(<span class="params">other: <span class="built_in">this</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> other.content === <span class="built_in">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> box = <span class="keyword">new</span> Box();</span><br><span class="line"><span class="built_in">console</span>.log(box.sameAs(box))</span><br></pre></td></tr></table></figure></li><li><p>这与其他写法不同: <code>Box</code> 如果有一个派生类，它的 <code>sameAs</code> 方法现在只能接受该同一派生类或其派生类的子类的其他实例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    content: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sameAs</span>(<span class="params">other: <span class="built_in">this</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> other.content === <span class="built_in">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedBox</span> <span class="keyword">extends</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    otherContent: <span class="built_in">string</span> = <span class="string">&quot;?&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> base = <span class="keyword">new</span> Box();</span><br><span class="line"><span class="keyword">const</span> derived = <span class="keyword">new</span> DerivedBox();</span><br><span class="line">base.sameAs(derived); <span class="comment">// 没有问题</span></span><br><span class="line">derived.sameAs(base); <span class="comment">// error 只能接受 派生类 DerivedBox及其子类 类型的实例</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="基于类型守卫的-this">基于类型守卫的 <code>this</code></h3><ol><li><p>可以在类和接口的方法返回位置使用 <code>this is Type</code>。当与类型缩小混合时(例如 <code>if</code> 语句)，目标对象的类型将被缩小到指定的 <code>Type</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystemObject</span> </span>&#123;</span><br><span class="line">    isFile(): <span class="built_in">this</span> is FileRep &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> <span class="keyword">instanceof</span> FileRep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isDirectory(): <span class="built_in">this</span> is Directory &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> <span class="keyword">instanceof</span> Directory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isNetworked(): <span class="built_in">this</span> is Networked &amp; <span class="built_in">this</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.networked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> path: <span class="built_in">string</span>, <span class="keyword">private</span> networked: <span class="built_in">boolean</span></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileRep</span> <span class="keyword">extends</span> <span class="title">FileSystemObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">path: <span class="built_in">string</span>, <span class="keyword">public</span> content: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(path, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">FileSystemObject</span> </span>&#123;</span><br><span class="line">    children: FileSystemObject[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Networked &#123;</span><br><span class="line">    host: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fso: FileSystemObject = <span class="keyword">new</span> FileRep(<span class="string">&quot;foo/bar&quot;</span>, <span class="string">&quot;baz&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> di: FileSystemObject = <span class="keyword">new</span> Directory(<span class="string">&quot;foo/bar&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> fs: FileSystemObject = <span class="keyword">new</span> FileSystemObject(<span class="string">&quot;foo/bar&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">switch1</span>(<span class="params">fso</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fso.isFile()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fso.content);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fso.isDirectory()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fso.path);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fso.isNetworked()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fso.host);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">switch1(fso);</span><br><span class="line">switch1(di);</span><br><span class="line">switch1(fs);</span><br></pre></td></tr></table></figure></li><li><p>基于 <code>this</code> 的类型保护的一个常见用例，是允许对一个特定字段进行懒惰验证。例如，下面这种情况：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    value?: T;</span><br><span class="line"></span><br><span class="line">    hasValue(): <span class="built_in">this</span> is &#123; <span class="attr">value</span>: T &#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value !== <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> box = <span class="keyword">new</span> Box&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">box.value = <span class="string">&quot;GameBoy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// box.value: string | undefined</span></span><br><span class="line"><span class="keyword">if</span> (box.hasValue()) &#123;</span><br><span class="line">    <span class="comment">// 这里已经可以推断出 box.value: string</span></span><br><span class="line">    <span class="built_in">console</span>.log(box.value.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="参数属性">参数属性</h3><ol><li><code>TS</code> 提供了特殊的语法，可以将构造函数变成具有相同名称和值的类属性。这些被称为参数属性，通过在构造函数参数前加上可见性修饰符 <code>public</code> <code>private</code> <code>protected</code> 或 <code>readony</code> 中的一个来创建。由此产生的字段会得到这些修饰符</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Params</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> x: <span class="built_in">number</span>, <span class="keyword">protected</span> y: <span class="built_in">number</span>, <span class="keyword">private</span> z: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Params(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.x);</span><br><span class="line"><span class="built_in">console</span>.log(a.y);</span><br></pre></td></tr></table></figure><h3 id="类表达式">类表达式</h3><ol><li>类表达式与类声明非常相似。唯一真正的区别是，类表达式不需要一个名字，尽管我们可以通过它们最终绑定的任何标识符来引用它们</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someClass = <span class="class"><span class="keyword">class</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    content: T;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value: T</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> someClass(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="抽象类和成员">抽象类和成员</h3><ol><li><p><code>TypeScript</code> 中的类、方法和字段可以是抽象的。一个抽象的方法或抽象的字段是一个没有提供实现的方法或字段。这些成员必须存在于一个抽象类中，不能直接实例化</p></li><li><p>抽象类的作用是作为子类的基类，实现所有的抽象成员。当一类没有任何抽象成员时，我们就说它是具体的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> getName(): <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">printName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Base(); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p>不能用 <code>new</code> 关键字来实例化 <code>Base</code> 因为它是抽象的。相反，我们需要创建一个派生类并实现抽象成员</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> Derived();</span><br><span class="line">d.printName();</span><br></pre></td></tr></table></figure></li><li><p>抽象构造签名</p><ul><li>如果想接受一些类的构造函数，产生一个从某些抽象类派生出来的类的实例</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 正确地告诉你，你正在试图实例化一个抽象类。毕竟鉴于 greet 的定义，写这段代码是完全合法的，它最终会构造一个抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">ctor: <span class="keyword">typeof</span> Base</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> ctor(); <span class="comment">// error 不能创建一个抽象类</span></span><br><span class="line">    instance.printName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 糟糕 </span></span><br><span class="line">greet(Base);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相反，写一个函数，接受具有结构化签名的东西</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">ctor: <span class="keyword">new</span>() =&gt; Base</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> ctor();</span><br><span class="line"></span><br><span class="line">    instance.printName();</span><br><span class="line">&#125;</span><br><span class="line">greet(Derived);</span><br><span class="line">greet(Base); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="类之间的关系">类之间的关系</h3><ol><li><p>在大多数情况下，<code>TypeScript</code> 中的类在结构上与其他类型相同，是可以比较的</p></li><li><p>例如，这两个类可以相互替代使用，因为它们是相同的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point1</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: Point1 = <span class="keyword">new</span> Point2(); <span class="comment">// 正确的</span></span><br></pre></td></tr></table></figure></li><li><p>同样的，即使没有明确的继承，类之间的子类型关系也是存在的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    salary: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: Person = <span class="keyword">new</span> Employee(); <span class="comment">// right</span></span><br></pre></td></tr></table></figure></li><li><p>这看起来很简单，但是有几种情况似乎比其他情况更奇怪。空的类没有成员，在一个结构化类型系统中，一个没有成员的类型通常是其它任何东西的超类型。所以如果你有一个空类，任何东西都可以用来代替它</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: Empty</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不能用 x 做任何事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn(<span class="built_in">window</span>);</span><br><span class="line">fn(&#123;&#125;);</span><br><span class="line">fn(fn);</span><br></pre></td></tr></table></figure></li></ol><h2 id="模块">模块</h2><h3 id="如何定义-JavaScript-模块">如何定义 <code>JavaScript</code> 模块</h3><ol><li>在 <code>TypeScript</code> 中，就像在 <code>ECMAScript2015</code> 中一样，任何包含顶级 <code>import</code> 或 <code>export</code> 的文件都被认为是模块</li><li>相反，一个没有任何顶级导入或导出声明的文件被视为一个脚本，其内容可在全局范围内使用(因此也可用于模块，例如 <code>import &quot;./index.js&quot;</code>)</li><li>模块在自己的范围内执行，而不是在全局范围。这意味着在模块中声明的变量、函数、类等在模块外是不可见的，除非它们被明确地用某种导出形式导出。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用导入的形式将其导入</li></ol><h3 id="非模块">非模块</h3><ol><li><p><code>JavaScript</code> 规范声明，任何没有 <code>export</code> 或顶层 <code>await</code> 的 <code>JavaScript</code> 文件都应该被认为是一个脚本而不是一个模块</p></li><li><p>在一个脚本文件中，变量和类型被声明为在共享全局范围内，并且假定会使用 <code>outFile</code> 编译器选项将多个输入文件加入一个输出文件，或者在你的 <code>html</code> 中使用 <code>script</code> 标签来加载这些文件</p></li><li><p>如果有一个目前没有任何导入或导出的文件，但希望被当作一个模块来处理，请添加这一行:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>这将改变该文件，使其成为一个什么都不输出的模块。无论你的模块目标是什么，这个语法都有效</p></li></ol><h3 id="TypeScript-中的模块"><code>TypeScript</code> 中的模块</h3><ol><li>在 <code>TypeScript</code> 中编写基于模块的代码时，有三个主要方面<ul><li>语法</li><li>模块解析</li><li>模块输出目标</li></ul></li></ol><h4 id="ES-模块语法">ES 模块语法</h4><ol><li><p>一个文件可以通过 <code>export default</code> 声明一个主要出口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">helloworld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">&quot;./hello.ts&quot;</span>;</span><br><span class="line">hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了默认的导出，还可以通过省略 default 的 export 实现一个以上的变量和函数的导出</span></span><br><span class="line"><span class="comment">// math.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> squareTwo = <span class="number">1.41</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> phi = <span class="number">1.61</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; pi, phi &#125; <span class="keyword">from</span> <span class="string">&quot;./math.ts&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(pi);</span><br></pre></td></tr></table></figure></li></ol><h4 id="额外的导入语法">额外的导入语法</h4><ol><li><p>可以使用 <code>import &#123; old as new &#125;</code> 这样的格式来重命名一个导入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; pi <span class="keyword">as</span> PI &#125; <span class="keyword">from</span> <span class="string">&quot;./math.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(PI);</span><br></pre></td></tr></table></figure></li><li><p>可以把所有导出的对象，用 <code>* as name</code> 放到一个命名空间</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">&quot;./math.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(math.pi);</span><br></pre></td></tr></table></figure></li><li><p>也可以通过 <code>import &quot;./file&quot;</code> 导入一个文件，而不把任何变量纳入你的当前模块。这种情况下，<code>import</code> 没有任何作用，然后 <code>math.ts</code> 中的所有代码都被解析了，这可能引发影响其他对象的副作用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./math.ts&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3.14</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="TypeScript-特定的-ES-模块语法"><code>TypeScript</code> 特定的 ES 模块语法</h4><ol><li><p>类型可以使用与 <code>JS</code> 值相同的语法进行导出和导入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Cat = &#123; <span class="attr">breed</span>: <span class="built_in">string</span>; yearOfBirth: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    breeds: <span class="built_in">string</span>[];</span><br><span class="line">    yearOfBirth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Cat, Dog &#125; <span class="keyword">from</span> <span class="string">&quot;./animal.ts&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> Animals = Cat | Dog;</span><br></pre></td></tr></table></figure></li><li><p><code>TS</code> 用了两个概念扩展了 <code>import</code> 语法，用于声明一个类型的导入</p><ul><li><code>import type</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Cat = &#123; <span class="attr">breed</span>: <span class="built_in">string</span>; yearOfBirth: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    breeds: <span class="built_in">string</span>[];</span><br><span class="line">    yearOfBirth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; Cat, Dog &#125; <span class="keyword">from</span> <span class="string">&quot;./animal.ts&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>内联类型导入</p><ul><li><code>TS4.5</code> 还允许以 <code>type</code> 为前缀的单个导入，以表明导入的引用是一个类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">type</span> Cat, <span class="keyword">type</span> Dog &#125; <span class="keyword">from</span> <span class="string">&quot;./animal.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Animals = Cat | Dog;</span><br></pre></td></tr></table></figure></li></ol><h4 id="ES-模块语法与-CommonJS-行为">ES 模块语法与 CommonJS 行为</h4><p><code>TS</code> 有 <code>ES Module</code> 语法，它直接与 <code>CommonJS</code> 和 <code>AMD</code> 的 <code>require</code> 想关联。使用 <code>ES Module</code> 的 <code>import</code> 在大多数情况下与这些环境的 <code>require</code> 相同，但这种语法确保你在 <code>TypeScript</code> 文件中与 <code>CommonJS</code> 的输出有1对1的匹配</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> code = fs.readFileSync(<span class="string">&quot;hello.ts&quot;</span>, <span class="string">&quot;utf8&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="CommonJS-语法"><code>CommonJS</code> 语法</h3><p><code>CommonJS</code> 是 <code>npm</code> 上大多数模块的交付格式</p><h4 id="导出">导出</h4><p>标识符是通过一个全局调用的 <code>module</code> 上设置 <code>exports</code> 属性来导出的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">absolute</span>(<span class="params">num: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> num * -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    pi: <span class="number">3.14</span>,</span><br><span class="line">    phi: <span class="number">1.61</span>,</span><br><span class="line">    absolute</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些文件可以通过 <code>require</code> 语句导入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maths = <span class="built_in">require</span>(<span class="string">&quot;maths&quot;</span>);</span><br><span class="line">maths.pi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; pi &#125; = <span class="built_in">require</span>(<span class="string">&quot;maths&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="CommonJS-和-ES-模块的互操作性"><code>CommonJS</code> 和 <code>ES</code> 模块的互操作性</h4><ol><li>关于默认导入和模块命名空间对象导入之间的区别，<code>CommonJS</code> 和 <code>ES Modules</code> 之间存在功能上的不匹配</li></ol><h3 id="TypeScript-的模块解析选项"><code>TypeScript</code> 的模块解析选项</h3><ol><li>模块解析是指从 <code>import</code> 或 <code>require</code> 语句中获取一个字符串，并确定该字符串所指的文件的过程</li><li><code>TS</code> 包括两种解析策略，经典和 <code>Node</code>。当编译器选项 <code>module</code> 不是 <code>commonjs</code> 时，经典策略是默认的，是为了向后兼容。<code>Node</code> 策略复制了 <code>Node</code> 在 <code>CommonJS</code> 模式下的工作方式，对 <code>.ts</code> 和 <code>.d.ts</code> 有额外的检查</li><li>在 <code>TS</code> 中，有许多 <code>TSConfig</code> 标志影响模块策略 <code>moduleResolution</code> <code>baseUrl</code> <code>paths</code> <code>rootDirs</code></li></ol><h3 id="TS-的模块输出选项"><code>TS</code> 的模块输出选项</h3><ol><li><p>有两个选项会影响 <code>JS</code> 输出</p><ul><li><code>target</code> 它决定了哪些 <code>JS</code> 功能被降级(转换在旧 js 运行时运行)，哪些保持不变</li><li><code>module</code> 它决定了哪些代码用于模块之间的相互作用</li></ul></li><li><p>使用的 <code>target</code> 由你期望运行 <code>TypeScript</code> 代码的 <code>JavaScript</code> 运行时中的可用功能决定的。这可能是：支持的最古老的网络浏览器，期望运行的最低版本的 <code>NodeJS</code>，或者可能来自于运行时的独特约束 — electron</p></li><li><p>所有模块之间的通信都是通过模块加载器进行的，编译器选项 <code>module</code> 决定使用哪一个。在运行时，模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖项</p></li><li><p>例如，这里是一个使用 <code>ES</code> 模块语法的 <code>TypeScript</code> 文件，展示了 <code>module</code> 的一些不同选项</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; valueOfPi &#125; <span class="keyword">from</span> <span class="string">&quot;./constants.js&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> twoPi = valueOfPi * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>ES2020</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; valueOfPi &#125; <span class="keyword">from</span> <span class="string">&quot;./constants.js&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> twoPi = valueOfPi * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>CommonJS</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">exports</span>.twoPi = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> constants_js_1 = <span class="built_in">require</span>(<span class="string">&quot;./constants.js&quot;</span>);</span><br><span class="line"><span class="built_in">exports</span>.twoPi = constants_js_1.valueOfPi * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li><code>UMD</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> v = factory(<span class="built_in">require</span>, <span class="built_in">exports</span>);</span><br><span class="line">        <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="built_in">module</span>.exports = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;./constants.js&quot;</span>], factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="built_in">exports</span>.twoPi = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> constants_js_1 = <span class="built_in">require</span>(<span class="string">&quot;./constants.js&quot;</span>);</span><br><span class="line">    <span class="built_in">exports</span>.twoPi = constants_js_1.valueOfPi * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="TS-命名空间"><code>TS</code> 命名空间</h3><p><code>TS</code> 有自己的模块格式，称为 命名空间，这比 <code>ES</code> 模块标准要早。这种语法对于创建复杂的定义文件有很多有用的功能，并且在 <code>DefinitelyTyped</code> 中仍然被积极使用。虽然没有被废弃，但命名空间中的大部分功能都存在于 <code>ES Modules</code> 中，我们建议使用与 <code>Js</code> 的方向保持一致</p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>typescript基础</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://blog.keyiqingxin.cn/9f47fabe/">https://blog.keyiqingxin.cn/9f47fabe/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>可以清心</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-06-30</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-02-11</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener external nofollow noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener external nofollow noreferrer" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/typescript/">typescript</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.keyiqingxin.cn/cover/552320.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/social-share/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.keyiqingxin.cn/social-share/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.keyiqingxin.cn/wechat/wechat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.keyiqingxin.cn/wechat/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/ff44d7d9/"><img class="prev-cover" src="https://cdn.keyiqingxin.cn/cover/517950.jpg" onerror='onerror=null,src="https://cdn.keyiqingxin.cn/avatar/avatar1.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用TensorFlow.js进行人脸动作检测</div></div></a></div><div class="next-post pull-right"><a href="/7bfffe12/"><img class="next-cover" src="https://cdn.keyiqingxin.cn/cover/572885.jpg" onerror='onerror=null,src="https://cdn.keyiqingxin.cn/avatar/avatar1.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">十分钟理解Object.defineProperty</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">TypeScript 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TSC-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">TSC 编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-number">1.2.</span> <span class="toc-text">发出错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">显式类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%A6%E6%8B%AD%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">擦拭类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7%E7%BC%96%E8%AF%91"><span class="toc-number">1.5.</span> <span class="toc-text">降级编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">严格模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">常用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typescript"><span class="toc-number">2.1.</span> <span class="toc-text">typescript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%85%83%E7%B1%BB%E5%9E%8B-number-string-boolean"><span class="toc-number">2.2.</span> <span class="toc-text">基元类型 number string boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any"><span class="toc-number">2.4.</span> <span class="toc-text">any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8A%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A"><span class="toc-number">2.5.</span> <span class="toc-text">变量上的类型注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A"><span class="toc-number">2.6.1.</span> <span class="toc-text">参数类型注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A"><span class="toc-number">2.6.2.</span> <span class="toc-text">返回类型注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.3.</span> <span class="toc-text">匿名函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.1.</span> <span class="toc-text">可选属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.8.</span> <span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.9.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.10.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">2.10.1.</span> <span class="toc-text">接口和类型别名之间的差异</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">2.11.</span> <span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.12.</span> <span class="toc-text">文字类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%8E%A8%E7%90%86"><span class="toc-number">2.12.1.</span> <span class="toc-text">文字推理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-%E5%92%8C-undefined"><span class="toc-number">2.13.</span> <span class="toc-text">null 和 undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.14.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%A4%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="toc-number">2.15.</span> <span class="toc-text">不太常见的原语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bigint"><span class="toc-number">2.15.1.</span> <span class="toc-text">bigint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symbol"><span class="toc-number">2.15.2.</span> <span class="toc-text">symbol</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.</span> <span class="toc-text">类型缩小</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof-%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB"><span class="toc-number">3.1.</span> <span class="toc-text">typeof 类型守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%80%BC%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.2.</span> <span class="toc-text">真值缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.3.</span> <span class="toc-text">等值缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.4.</span> <span class="toc-text">in 操作符缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.5.</span> <span class="toc-text">instanceof 操作符缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.6.</span> <span class="toc-text">分配缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-number">3.7.</span> <span class="toc-text">控制流分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D"><span class="toc-number">3.8.</span> <span class="toc-text">使用类型谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E6%AD%A7%E8%A7%86%E7%9A%84-unions"><span class="toc-number">3.9.</span> <span class="toc-text">受歧视的 unions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%A9%B7%E5%B0%BD%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">3.10.</span> <span class="toc-text">never 类型与穷尽性检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9B%B4%E5%A4%9A"><span class="toc-number">4.</span> <span class="toc-text">函数更多</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">函数类型表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D"><span class="toc-number">4.2.</span> <span class="toc-text">调用签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-number">4.3.</span> <span class="toc-text">构造签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">泛型函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">4.4.1.</span> <span class="toc-text">类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.4.2.</span> <span class="toc-text">限制条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%97%E9%99%90%E5%80%BC"><span class="toc-number">4.4.3.</span> <span class="toc-text">使用受限值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.4.</span> <span class="toc-text">指定类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%BC%98%E7%A7%80%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">4.4.5.</span> <span class="toc-text">编写优秀通用函数的准则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">可选参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text">回调中的可选参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">4.6.</span> <span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%AD%BE%E5%90%8D%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">4.6.1.</span> <span class="toc-text">重载签名和实现签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">4.6.2.</span> <span class="toc-text">编写好的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%85-This-%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.6.3.</span> <span class="toc-text">函数内 This 的声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.7.</span> <span class="toc-text">需要了解的其他类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#void"><span class="toc-number">4.7.1.</span> <span class="toc-text">void</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object"><span class="toc-number">4.7.2.</span> <span class="toc-text">object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unknown"><span class="toc-number">4.7.3.</span> <span class="toc-text">unknown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#never"><span class="toc-number">4.7.4.</span> <span class="toc-text">never</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function"><span class="toc-number">4.7.5.</span> <span class="toc-text">Function</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.8.</span> <span class="toc-text">参数展开运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%B1%95%E5%BC%80"><span class="toc-number">4.8.1.</span> <span class="toc-text">形参展开</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E5%8F%82%E5%B1%95%E5%BC%80"><span class="toc-number">4.8.2.</span> <span class="toc-text">实参展开</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84"><span class="toc-number">4.9.</span> <span class="toc-text">参数解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E5%88%86%E9%85%8D%E6%80%A7"><span class="toc-number">4.10.</span> <span class="toc-text">函数的可分配性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-void-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.10.1.</span> <span class="toc-text">返回 void 类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">5.</span> <span class="toc-text">对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">属性修改器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7-2"><span class="toc-number">5.1.1.</span> <span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.2.</span> <span class="toc-text">只读属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">5.1.3.</span> <span class="toc-text">索引签名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">扩展类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">接口与交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">范型对象类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.</span> <span class="toc-text">数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.7.</span> <span class="toc-text">只读数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.8.</span> <span class="toc-text">元组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.9.</span> <span class="toc-text">只读元组类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%8D%E7%BA%B5"><span class="toc-number">6.</span> <span class="toc-text">类型操纵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">通用类型变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.2.</span> <span class="toc-text">泛型类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">6.1.3.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.1.4.</span> <span class="toc-text">泛型约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">6.1.5.</span> <span class="toc-text">在泛型约束中使用类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%B3%9B%E5%9E%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.6.</span> <span class="toc-text">在泛型中使用类类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keyof-%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">keyof 类型操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typeof-%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">6.3.</span> <span class="toc-text">Typeof 类型操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.4.</span> <span class="toc-text">索引访问类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.5.</span> <span class="toc-text">条件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.5.1.</span> <span class="toc-text">条件类型约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%86%85%E8%BF%9B%E8%A1%8C%E6%8E%A8%E7%90%86"><span class="toc-number">6.5.2.</span> <span class="toc-text">在条件类型内进行推理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.5.3.</span> <span class="toc-text">分布式条件类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.6.</span> <span class="toc-text">映射类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E4%BF%AE%E6%94%B9%E5%99%A8"><span class="toc-number">6.6.1.</span> <span class="toc-text">映射修改器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-as-%E5%81%9A-key-%E9%87%8D%E6%98%A0%E5%B0%84"><span class="toc-number">6.6.2.</span> <span class="toc-text">通过 as 做 key 重映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">7.1.</span> <span class="toc-text">类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">类型属性的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly"><span class="toc-number">7.1.2.</span> <span class="toc-text">readonly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">7.1.3.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.4.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Getters-Setters"><span class="toc-number">7.1.5.</span> <span class="toc-text">Getters &#x2F; Setters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D-2"><span class="toc-number">7.1.6.</span> <span class="toc-text">索引签名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">7.2.</span> <span class="toc-text">类继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#implements-%E5%AD%90%E5%8F%A5"><span class="toc-number">7.2.1.</span> <span class="toc-text">implements 子句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extends-%E5%AD%90%E5%8F%A5"><span class="toc-number">7.2.2.</span> <span class="toc-text">extends 子句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.3.</span> <span class="toc-text">重写方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.2.4.</span> <span class="toc-text">初始化顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.5.</span> <span class="toc-text">继承内置类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">7.3.</span> <span class="toc-text">成员的可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#public"><span class="toc-number">7.3.1.</span> <span class="toc-text">public</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protected"><span class="toc-number">7.3.2.</span> <span class="toc-text">protected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#private"><span class="toc-number">7.3.3.</span> <span class="toc-text">private</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">7.4.</span> <span class="toc-text">静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E9%9D%99%E6%80%81%E5%90%8D%E7%A7%B0"><span class="toc-number">7.4.1.</span> <span class="toc-text">特殊的静态名称</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%87%8C%E7%9A%84-static-%E5%8C%BA%E5%9D%97"><span class="toc-number">7.5.</span> <span class="toc-text">类里的 static 区块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB-2"><span class="toc-number">7.6.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84-this"><span class="toc-number">7.7.</span> <span class="toc-text">类运行时的 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.8.</span> <span class="toc-text">this 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB%E7%9A%84-this"><span class="toc-number">7.9.</span> <span class="toc-text">基于类型守卫的 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">7.10.</span> <span class="toc-text">参数属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.11.</span> <span class="toc-text">类表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98"><span class="toc-number">7.12.</span> <span class="toc-text">抽象类和成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.13.</span> <span class="toc-text">类之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">8.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89-JavaScript-%E6%A8%A1%E5%9D%97"><span class="toc-number">8.1.</span> <span class="toc-text">如何定义 JavaScript 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%A8%A1%E5%9D%97"><span class="toc-number">8.2.</span> <span class="toc-text">非模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">8.3.</span> <span class="toc-text">TypeScript 中的模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES-%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95"><span class="toc-number">8.3.1.</span> <span class="toc-text">ES 模块语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E5%AF%BC%E5%85%A5%E8%AF%AD%E6%B3%95"><span class="toc-number">8.3.2.</span> <span class="toc-text">额外的导入语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-%E7%89%B9%E5%AE%9A%E7%9A%84-ES-%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95"><span class="toc-number">8.3.3.</span> <span class="toc-text">TypeScript 特定的 ES 模块语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES-%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95%E4%B8%8E-CommonJS-%E8%A1%8C%E4%B8%BA"><span class="toc-number">8.3.4.</span> <span class="toc-text">ES 模块语法与 CommonJS 行为</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonJS-%E8%AF%AD%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">CommonJS 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA"><span class="toc-number">8.4.1.</span> <span class="toc-text">导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CommonJS-%E5%92%8C-ES-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7"><span class="toc-number">8.4.2.</span> <span class="toc-text">CommonJS 和 ES 模块的互操作性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E7%9A%84%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90%E9%80%89%E9%A1%B9"><span class="toc-number">8.5.</span> <span class="toc-text">TypeScript 的模块解析选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TS-%E7%9A%84%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E9%80%89%E9%A1%B9"><span class="toc-number">8.6.</span> <span class="toc-text">TS 的模块输出选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TS-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">8.7.</span> <span class="toc-text">TS 命名空间</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By 可以清心</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="to_comment" type="button" title="直达评论" onclick="FixedCommentBtn()"><i class="fas fa-comments"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.keyiqingxin.cn/js/utils.js"></script><script src="https://cdn.keyiqingxin.cn/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.keyiqingxin.cn/snackbar/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.keyiqingxin.cn",region:""},null))},n=()=>{twikoo.getCommentsCount({envId:"https://twikoo.keyiqingxin.cn",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},e=(e=!1)=>{"object"==typeof twikoo?(o(),e&&t&&setTimeout(n,0)):getScript("https://cdn.keyiqingxin.cn/twikoo/twikoo.all.min.js").then(()=>{o(),e&&t&&setTimeout(n,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),e)})()</script><script>function loadWaline(){function n(){new Waline(Object.assign({el:"#waline-wrap",serverURL:"https://waline.keyiqingxin.cn",avatar:"monsterid",path:location.pathname,emojiCDN:"",emojiMaps:"",visitor:!1},{login:"enable"}))}"function"==typeof Waline?n():getScript("https://cdn.keyiqingxin.cn/waline/Waline.min.js").then(n)}{function loadOtherComment(){loadWaline()}}</script></div><div class="aplayer no-destroy" data-id="2495595989" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script async src="https://cdn.keyiqingxin.cn/js/font_2264842_3izu8i5eoc2.js"></script><script defer src="https://cdn.keyiqingxin.cn/live2d-widget/autoload.js"></script><script defer src="https://cdn.keyiqingxin.cn/js/live2dcubismcore.min.js"></script><script defer src="https://cdn.keyiqingxin.cn/js/asyncmodel.min.js"></script><script src="https://cdn.keyiqingxin.cn/twikoo/twikoo.all.min.js"></script><div id="live3d" class="live3d" style="position:fixed;left:-100px;bottom:-20px;width:500px!important;height:437.5px!important;z-index:98"><canvas id="live2dm" class="live3d"></canvas></div><script data-pjax defer src="https://cdn.keyiqingxin.cn/js/fixed_comment.js"></script><script data-pjax defer src="https://cdn.keyiqingxin.cn/js/comment_barrage.js"></script><script>let tianliGPT_postSelector="#post #article-container",tianliGPT_key="nHC6jHq3oJ4trKTHCPyn"</script><script src="https://cdn.keyiqingxin.cn/tianli_gpt/tianli-gpt.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.keyiqingxin.cn/butterfly-extsrc/fireworks.min.js"></script><script src="https://cdn.keyiqingxin.cn/butterfly-extsrc/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.keyiqingxin.cn/aplayer/APlayer.min.js"></script><script src="https://cdn.keyiqingxin.cn/meting/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨空间站上新啦！ 👉</label><a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍭查看新品🍬</span></a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"✨ 空间站上新啦！ 👉",backgroundColor:t,duration:5e5,pos:e,actionText:"🍭查看新品🍬",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",(function(){showNotification()})),window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js")})))</script></div><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&"/"===location.pathname&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.keyiqingxin.cn/bdhistory/js/main.js"></script><script data-pjax>if(document.getElementById("recent-posts")&&"/"==location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/1111069.png" alt="https://cdn.keyiqingxin.cn/cover/1111069.png"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-09-17</span><a class="blog-slider__title" href="679887a0/">butterfly分类页面魔改</a><div class="blog-slider__text">butterfly分类页面魔改</div><a class="blog-slider__button" href="679887a0/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/939928.jpg" alt="https://cdn.keyiqingxin.cn/cover/939928.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-08-26</span><a class="blog-slider__title" href="df8718c1/">网格布局</a><div class="blog-slider__text">css 网格布局(grid)</div><a class="blog-slider__button" href="df8718c1/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/1111259.png" alt="https://cdn.keyiqingxin.cn/cover/1111259.png"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-08-02</span><a class="blog-slider__title" href="9b2de178/">vue2.x的api</a><div class="blog-slider__text">vue2.x的api</div><a class="blog-slider__button" href="9b2de178/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/1111254.jpg" alt="https://cdn.keyiqingxin.cn/cover/1111254.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-07-28</span><a class="blog-slider__title" href="262ac49e/">vue2.x进阶用法</a><div class="blog-slider__text">vue2.x的一些进阶用法</div><a class="blog-slider__button" href="262ac49e/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/670098.jpg" alt="https://cdn.keyiqingxin.cn/cover/670098.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-07-09</span><a class="blog-slider__title" href="c0add594/">vue2.x基本用法</a><div class="blog-slider__text">vue2.x基本用法</div><a class="blog-slider__button" href="c0add594/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/1111255.jpg" alt="https://cdn.keyiqingxin.cn/cover/1111255.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-07-01</span><a class="blog-slider__title" href="5650e2f5/">vercel托管node.js的api服务</a><div class="blog-slider__text">vercel托管node.js的api服务</div><a class="blog-slider__button" href="5650e2f5/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/942531.jpg" alt="https://cdn.keyiqingxin.cn/cover/942531.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-06-01</span><a class="blog-slider__title" href="317ea436/">bufferfly主题的应用和即时推送</a><div class="blog-slider__text">bufferfly主题的应用和即时推送</div><a class="blog-slider__button" href="317ea436/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/829919.png" alt="https://cdn.keyiqingxin.cn/cover/829919.png"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-06-01</span><a class="blog-slider__title" href="bf0e4745/">bufferfly主题的一些美化</a><div class="blog-slider__text">bufferfly 主题的一些美化</div><a class="blog-slider__button" href="bf0e4745/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/820208.png" alt="https://cdn.keyiqingxin.cn/cover/820208.png"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-06-01</span><a class="blog-slider__title" href="f5fee1ca/">发布一个npm包</a><div class="blog-slider__text">发布一个npm包</div><a class="blog-slider__button" href="f5fee1ca/">🍡详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';console.log("已挂载swiper"),parent.insertAdjacentHTML("afterbegin",child)}</script><script data-pjax src="https://cdn.keyiqingxin.cn/zfswiper/swiper.min.js"></script><script data-pjax src="https://cdn.keyiqingxin.cn/zfswiper/swiperindex.js"></script><style></style><script data-pjax src="https://cdn.keyiqingxin.cn/js/github.js"></script><script data-pjax>function GithubCalendarConfig(){var t=document.getElementById("recent-posts");t&&"/"==location.pathname&&(console.log("已挂载github calendar"),t.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://python.keyiqingxin.cn/api?name=milkdue",["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"],"milkdue")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style></style><script data-pjax>function butterfly_footer_beautify_injector_config(){var e=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),e.insertAdjacentHTML("beforeend",'<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="主题采用butterfly" title=""><img src="https://cdn.keyiqingxin.cn/svg/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站已在工信部备案，备案号陕ICP备2023000684号-1" title=""><img src="https://cdn.keyiqingxin.cn/svg/bei.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20210025" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站已加入萌ICP豪华套餐，萌ICP备20210025号" title=""><img src="https://cdn.keyiqingxin.cn/svg/moe.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站使用腾讯云为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-腾讯云-blue?style=flat&amp;logo=icloud" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站默认线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站项目由Gtihub托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.keyiqingxin.cn/wow/wow.min.js"></script><script defer src="https://cdn.keyiqingxin.cn/wow/wow_init.js"></script><script defer src="https://cdn.keyiqingxin.cn/jquery/jquery.min.js"></script><script defer src="https://cdn.keyiqingxin.cn/kity/kity.min.js"></script><script defer src="https://cdn.keyiqingxin.cn/kityminder/kityminder.core.min.js"></script><script defer src="https://cdn.keyiqingxin.cn/tag_plugin/mindmap.js"></script><script async src="https://cdn.keyiqingxin.cn/js/font_2032782_8d5kxvn09md.js"></script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",(function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach((function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)}))}))</script><script>!function(t){t.imageLazyLoadSetting.processImages=o;var e=t.imageLazyLoadSetting.isSPA,n=t.imageLazyLoadSetting.preloadRatio||1,i=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(i=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var o,a=0;a<i.length;a++)0<=(o=(o=i[a]).getBoundingClientRect()).bottom&&0<=o.left&&o.top<=(t.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,o,r=i[a];t=r,e=function(){i=i.filter((function(t){return r!==t}))},n=new Image,o=t.getAttribute("data-original"),n.onload=function(){t.src=o,e&&e()},t.src!==o&&(n.src=o)}()}o(),t.addEventListener("scroll",(function(){var e,n;e=o,n=t,clearTimeout(e.tId),e.tId=setTimeout((function(){e.call(n)}),500)}))}(this)</script></body></html>