<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>typescript学习笔记 | 可以清心</title><meta name="keywords" content="typescript"><meta name="author" content="可以清心"><meta name="copyright" content="可以清心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="tensorflow"><meta property="og:type" content="article"><meta property="og:title" content="typescript学习笔记"><meta property="og:url" content="https://blog.keyiqingxin.cn/9f47fabe/index.html"><meta property="og:site_name" content="可以清心"><meta property="og:description" content="tensorflow"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.keyiqingxin.cn/cover/552320.jpg"><meta property="article:published_time" content="2023-06-29T16:08:01.000Z"><meta property="article:modified_time" content="2024-12-27T00:04:39.774Z"><meta property="article:author" content="可以清心"><meta property="article:tag" content="typescript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.keyiqingxin.cn/cover/552320.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.keyiqingxin.cn/9f47fabe/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="baidu_site_verification" content="code-vvu3hMVkFQ"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#212121"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/favicon-16x16.png"><link rel="mask-icon" href="/img/siteicon/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/index.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/fontawesome/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/snackbar/snackbar.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?1668a6d436fb091fab3554501beeff3a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:1,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:{limitDay:30,position:"top",messagePrev:"读者请注意，本文章更新于",messageNext:"天前，文中某些信息可能已经过时，如有任何问题，请在文章末尾评论处留言！"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"吾辈宣布你的剪贴板已经被我占领啦！",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#2d3035",position:"top-center"},source:{jQuery:"https://cdn.keyiqingxin.cn/jquery/jquery.min.js",justifiedGallery:{js:"https://cdn.keyiqingxin.cn/justifiedGallery/js/jquery.justifiedGallery.min.js",css:"https://cdn.keyiqingxin.cn/justifiedGallery/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.keyiqingxin.cn/fancybox/jquery.fancybox.min.js",css:"https://cdn.keyiqingxin.cn/fancybox/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-12-27 08:04:39"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px")})(window)</script><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/my.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/twikoo_beautify.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/fixed_comment.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/comment_barrage.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/tianli_gpt/tianli-gpt.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/bdhistory/css/main.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/zfswiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/zfswiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/runtime/runtime.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/animate/animate.min.css" media="print" onload='this.media="screen"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/css/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/tag_plugin/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.keyiqingxin.cn/carousel/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/tag_plugin/mindmap.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg" style="background:url(https://cdn.keyiqingxin.cn/cover/552320.jpg);background-attachment:local;background-position:center;background-size:cover;background-repeat:no-repeat"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.keyiqingxin.cn/avatar/avatar.jpg" onerror='onerror=null,src="https://cdn.keyiqingxin.cn/avatar/avatar1.jpg"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分類</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>光影</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i> <span>清單</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音樂</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>電影</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://picx.xpoet.cn/"><i class="fa-fw fa fa-bed"></i> <span>图床</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/chart/"><i class="fa-fw fa fa-map"></i> <span>統計</span></a></div><div class="menus_item"><a class="site-page" href="/sponsor/"><i class="fa-fw fa fa-gift"></i> <span>贊助</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友鏈</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.keyiqingxin.cn/cover/552320.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">可以清心</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分類</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i> <span>光影</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i> <span>清單</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音樂</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>電影</span></a></li><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="https://picx.xpoet.cn/"><i class="fa-fw fa fa-bed"></i> <span>图床</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/chart/"><i class="fa-fw fa fa-map"></i> <span>統計</span></a></div><div class="menus_item"><a class="site-page" href="/sponsor/"><i class="fa-fw fa fa-gift"></i> <span>贊助</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友鏈</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">typescript学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-29T16:08:01.000Z" title="发表于 2023-06-30 00:08:01">2023-06-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-27T00:04:39.774Z" title="更新于 2024-12-27 08:04:39">2024-12-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0-%E6%95%99%E7%A8%8B/">学习&amp;教程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="typescript学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="TypeScript-入门"><code>TypeScript</code> 入门</h2><h3 id="TSC-编译器"><code>TSC</code> 编译器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.ts</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><h3 id="发出错误">发出错误</h3><ol><li><code>--noEmitOnError</code> 不允许发生错误，一旦发生错误将不会生成 <code>js</code> 文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --noEmitOnError hello.ts</span><br></pre></td></tr></table></figure><h3 id="显式类型">显式类型</h3><ol><li>明确指定参数或变量的类型</li><li>但是我们不总是需要编写明确的类型，在大多数情况下，<code>TypeScript</code> 会自动推断代码中的类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: <span class="built_in">string</span>, data: <span class="built_in">Date</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;suxi&quot;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure><h3 id="擦拭类型">擦拭类型</h3><ol><li><code>tsc</code> 编译后的 <code>js</code> 将类型擦除掉</li><li>类型注释永远不会改变程序的运行时行为</li></ol><h3 id="降级编译">降级编译</h3><ol><li><code>tsc</code> 指定编译生成 <code>js</code> 的版本</li><li><code>tsc --target es2015 hello.ts</code></li></ol><h3 id="严格模式">严格模式</h3><ol><li><code>tsc --strict true hello.ts</code> 开启严格模式</li><li><code>tsc --strict true --noImplictAny true</code> 开启严格模式，并且当类型隐式推断为 <code>any</code> 时发出错误</li><li><code>tsc --target es2015 --strictNullChecks true</code> <code>null</code> 和 <code>undefined</code> 可以分配给任意类型，这可能会导致空异常，开启 <code>strictNullChecks</code> 可以防止出现空异常</li></ol><h2 id="常用类型">常用类型</h2><h3 id="typescript"><code>typescript</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2016&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./src&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基元类型-number-string-boolean">基元类型 <code>number</code> <code>string</code> <code>boolean</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> s: <span class="built_in">string</span> = <span class="string">&quot;abs&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="数组">数组</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> strs: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>];</span><br></pre></td></tr></table></figure><h3 id="any"><code>any</code></h3><ol><li>当不希望某个特定值导致类型检查错误时，可以使用 <code>any</code></li><li>当一个值的类型是 <code>any</code> 时，可以访问它的任何属性，将它分配给任何类型的值</li><li>但在运行环境下执行代码可能是错误的</li><li>当我们不指定类型时，并且 <code>typescript</code> 无法从上下文推断它时，编译器通常会默认为 <code>any</code>，但是通常情况下，我们需要避免这种情况，因为 <code>any</code> 没有进行类型检查，使用 <code>noImplicitAny</code> 将任何隐式标记 <code>any</code> 为错误</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">any</span> = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br><span class="line">obj.bar = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> n: <span class="built_in">number</span> = obj;</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="变量上的类型注释">变量上的类型注释</h3><ol><li>可以选择添加类型注释来显式指定变量的类型</li><li>但是这不是必须的，因为 <code>typescript</code> 会尝试自动推断代码中的类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: <span class="built_in">string</span> = <span class="string">&quot;suxi&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">&quot;peiqi&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="函数">函数</h3><h4 id="参数类型注释">参数类型注释</h4><ol><li>即便没有参数类型注释，仍然会检查参数的数量</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="number">42</span>); <span class="comment">// error</span></span><br><span class="line">greet(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;456&quot;</span>); <span class="comment">// error</span></span><br><span class="line">greet(<span class="string">&quot;42&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="返回类型注释">返回类型注释</h4><ol><li>通常不需要返回类型，因为 <code>typescript</code> 会推断出返回类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumber</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名函数">匿名函数</h4><ol><li>匿名函数与函数声明有所不同，当一个函数出现在 <code>typescript</code> 可以确定它将如何被调用的地方时，该函数的参数会自动指定类型</li><li>上下文推断类型，函数发生在其中的上下文通知它应该具有什么类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>];</span><br><span class="line"><span class="comment">// 自动推断 name 为 string</span></span><br><span class="line">names.forEach(<span class="function"><span class="params">name</span> =&gt;</span> <span class="built_in">console</span>.log(name.toUpperCase()));</span><br></pre></td></tr></table></figure><h3 id="对象类型">对象类型</h3><ol><li>下面是一个对象类型的例子</li><li><code>x</code> 和 <code>y</code> 是对象的属性，它们的类型为 <code>number</code></li><li>可以使用 <code>,</code> 或 <code>;</code> 分隔属性，最后一个分割符是可选的</li><li>每个属性的类型部分也是可选的，如果不指定类型，则将假定为 <code>any</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: &#123; <span class="attr">x</span>: <span class="built_in">number</span>; y: <span class="built_in">number</span>; &#125; = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可选属性">可选属性</h4><ol><li>对象类型还可以指定其部分或全部属性是可选的</li><li>在属性后添加 <code>?</code> 表示其可选属性</li><li>当使用可选属性时，首先要判断是否存在</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: &#123; <span class="attr">x</span>: number; y: number; z?: number &#125; = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (point.z !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;三维坐标&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;二维坐标&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span>,</span><br><span class="line">    z: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="联合类型">联合类型</h3><p><code>typescript</code> 允许使用多种运算符从现有类型中构建新类型</p><ol><li><p>定义联合类型</p><ul><li>联合类型是由多个其他类型组成的类型，表示可以是这些类型中的任何一种类型</li><li>这些类型中的每一种类型称为联合类型的成员</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id);</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="number">123</span>);</span><br><span class="line">print(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用联合类型</p><ul><li>提供联合类型很容易，但是使用时，如果联合的每个成员都有效，<code>ts</code> 将只允许使用联合做一些事情，例如，如果 <code>string | number</code> 联合类型，不能只使用一种类型的操作</li><li>而是使用代码缩小联合，就像没有类型注释的 <code>js</code> 一样，当 <code>ts</code> 可以根据代码结构为值推断为具体的类型时，就会发生缩小</li><li>当然有时对于一个 <code>union</code> 所有成员都有一些共同点，例如，数组和字符串都有一个 <code>slice</code> 方法那么使用该属性就可以不会缩小范围</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id.toUpperCase())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// id 为 string</span></span><br><span class="line">        <span class="built_in">console</span>.log(id.toUpperCase())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// id 为 number</span></span><br><span class="line">        <span class="built_in">console</span>.log(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstThree</span>(<span class="params">x: <span class="built_in">number</span>[] | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.slice(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="类型别名">类型别名</h3><ol><li>如果我们想要多次使用一个类型，恰好这个类型的定义又很复杂，我们可以使用类型别名来声明类型，以便于多次引用它</li><li>当然类型别名只是别名，不能使用类型别名来创建相同类型的不同版本</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    z?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point: Point = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ID = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><h3 id="接口">接口</h3><ol><li>接口声明是另一种方式来命名对象类型</li><li><code>ts</code> 只关注类型的结构和功能</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    z?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point: Point = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span>,</span><br><span class="line">    z: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口和类型别名之间的差异">接口和类型别名之间的差异</h4><ol><li>类型别名和接口非常相似，在多数情况下可以自由的选择它们，几乎所有功能都在 <code>interface</code> 中可用 <code>type</code> 关键区别在于扩展新类型的方式不同</li><li>类型别名可能不参与声明合并，但接口可以</li><li>接口只能用于声明对象的形状，不能重命名基元</li><li>接口名称将始终以其原始形式出现在错误消息中，但仅当它们按名称使用时</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展接口</span></span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bear <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    honey: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bear: Bear = &#123;</span><br><span class="line">    name: <span class="string">&quot;winnie&quot;</span>,</span><br><span class="line">    honey: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bear.name;</span><br><span class="line">bear.honey;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过交叉点扩展类型</span></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bear = Animal &amp; &#123;</span><br><span class="line">    honey: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bear: Bear = &#123;</span><br><span class="line">    name: <span class="string">&quot;winnie&quot;</span>,</span><br><span class="line">    honey: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bear.name;</span><br><span class="line">bear.honey;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向现有类型添加新字段</span></span><br><span class="line"><span class="keyword">interface</span> MyWindow &#123;</span><br><span class="line">    title: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> MyWindow &#123;</span><br><span class="line">    content: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> w: MyWindow = &#123;</span><br><span class="line">    title: <span class="string">&quot;hello ts&quot;</span>,</span><br><span class="line">    content: <span class="string">&quot;ts is pop&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型创建后不可更改</span></span><br><span class="line"><span class="keyword">type</span> MyWindow = &#123;</span><br><span class="line">    title: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyWindow = &#123;</span><br><span class="line">    content: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型断言">类型断言</h3><ol><li><p>有时，我们会获得有关 <code>TS</code> 不知道的值类型的信息，例如 <code>document.getElementById</code> ， <code>TS</code> 只知道它将返回某种类型的 <code>HTMLElement</code> 但我们自己知道它将始终返回 <code>HTMLCanvasElement</code> 类型与穷尽性检查，这种情况下，我们需要类型断言来指定更加具体的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>) <span class="keyword">as</span> HTMLCanvasElement;</span><br></pre></td></tr></table></figure></li><li><p>和类型注释一样，类型断言不会影响代码的运行行为并由编译器删除断言，当然也可以使用 <code>&lt;&gt;</code> 进行断言，它们是等效的，但是需要注意这种方式不可以用在 <code>tsx</code> 中</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = &lt;HTMLCanvasElement&gt;<span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>TS</code> 只允许断言转换为更具体或不太具体的类型版本，此规则可防止不可能的断言</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可能的断言 因为这两种类型没有充分重叠</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="string">&quot;hello&quot;</span> <span class="keyword">as</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 需要先断言为 unknown 或 any 类型 在断言为 number 类型</span></span><br><span class="line"><span class="keyword">const</span> (x = <span class="string">&quot;hello&quot;</span> <span class="keyword">as</span> unknown) <span class="keyword">as</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="文字类型">文字类型</h3><ol><li><p>除了一般类型 <code>string</code> <code>number</code>，我们还可以在类型位置引用特定的字符串和数字</p></li><li><p>一种方法是考虑 <code>js</code> 如何以不同的方式声明变量</p><ul><li><code>var</code> <code>let</code> 两者都允许更改变量中保存的内容</li><li><code>const</code> 不允许，这反映在 <code>ts</code> 如何为文字创建类型上</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testString = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">testString = <span class="string">&quot;123&quot;</span>; <span class="comment">// 可以任意更改 相当于 testString的类型是 string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> constantString = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">// 已经不能在更改了，它只能表示一个可能的字符串，所有实际上 constantString 的类型是 &quot;hello world&quot; 这就是文字类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但就其本身而言，文字类型并不是很有价值</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="string">&quot;hello&quot;</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">x = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&quot;xxxx&quot;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li><li><p>拥有一个只能有一个值的变量并没有多大用处，但是通过将文字组合成联合类型，可以用来表达一个更有用的概念 — 例如只接受一组特定的值</p></li><li><p>当然文字类型也可以和非文字类型结合使用</p></li><li><p>还有一种文字类型：布尔文字，只有两种布尔文字类型，它们是类型 <code>true</code> 和 <code>false</code> 注意，此时他们是文字类型，不是值。那么基元 <code>boolean</code> 也本身是联合类型 <code>true</code> | <code>false</code> 的别名，可以这样理解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printText</span>(<span class="params">s: <span class="built_in">string</span>, align: <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s, align);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printText(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;left&quot;</span>);</span><br><span class="line">printText(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;right&quot;</span>);</span><br><span class="line">printText(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;center&quot;</span>); <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): -1 | 0 | 1 </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a === b ? <span class="number">0</span> : a &gt; b ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Options &#123;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configure</span>(<span class="params">x: Options | <span class="string">&quot;auto&quot;</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">configure(&#123; <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br><span class="line">configure(<span class="string">&quot;auto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> auto = <span class="string">&quot;auto&quot;</span>; <span class="comment">// 注意 这是 string 隐式 它不是文字类型 而是基元 string 不能直接 configure(auto) 这是错误的</span></span><br><span class="line"><span class="comment">// configure(auto);</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="文字推理">文字推理</h4><ol><li><p>当我们使用对象初始化变量时，<code>TS</code> 假定该对象的属性稍后可能会更改值</p><ul><li>所以 <code>const</code> 定义对象时，并不认为 <code>counter</code> 就是一个文字类型，而是认为它是一个基元 <code>number</code>，所以我们改变 <code>counter</code> 的值，<code>ts</code> 并不认为它是错误的</li><li>这也符合 <code>js</code> 中的行为</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;; <span class="comment">// 注意对象 const counter 属性可能改变</span></span><br><span class="line">obj.counter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">obj.counter = <span class="string">&quot;number&quot;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li><li><p>上面的行为同样适用于字符串</p></li><li><p>可以使用 <code>as const</code> 将整个对象转换为类型文字，就是说，确保了对象的所有属性分配的都是文字类型，而不是一个更一般的 <code>string</code> <code>number</code> 等</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRequest</span>(<span class="params">url: <span class="built_in">string</span>, method: <span class="string">&quot;GET&quot;</span> | <span class="string">&quot;POST&quot;</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = &#123; <span class="attr">url</span>: <span class="string">&quot;https://example.com&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span> &#125;;</span><br><span class="line">handleRequest(req.url, req.method); <span class="comment">// error req.method 不是 &quot;GET&quot; | &quot;POST&quot; 类型 而是 string 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种方式解决</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 在任意位置使用类型断言</span></span><br><span class="line"><span class="comment">// 1.1 第一种 始终保持 req.method 拥有文字类型 &quot;GET&quot; 防止之后可能赋值其他类型 例如 POSt</span></span><br><span class="line"><span class="keyword">const</span> req = &#123; <span class="attr">url</span>: <span class="string">&quot;https://example.com&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span> <span class="keyword">as</span> <span class="string">&quot;GET&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 1.2 第二种 我知道有其他原因 `req.method` 具有 GET 值</span></span><br><span class="line">handleRequest(req.url, req.method <span class="keyword">as</span> <span class="string">&quot;GET&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 将整对象转为文字类型</span></span><br><span class="line"><span class="keyword">const</span> req = &#123; <span class="attr">url</span>: <span class="string">&quot;https://example.com&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// req的类型实际上是 &#123; url: &quot;https://example.com&quot;; method: &quot;GET&quot; &#125; 可以这样理解</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="null-和-undefined"><code>null</code> 和 <code>undefined</code></h3><ol><li><p><code>js</code> 中 <code>null</code> 和 <code>undefined</code> 表示不存在或未初始化的值</p></li><li><p><code>ts</code> 中有两个对应的同名类型，这些类型的行为取决于是否设置了 <code>strictNullChecks</code> 选项</p><ul><li>关闭 <code>false</code> 依然可以正常访问的值，并且可以将值分配给任何类型的属性。这类似没有空检查的语言 (<code>c#</code> <code>java</code>)，缺少空检查往往是错误的主要来源</li><li>开启，需要在对值使用之前测试这些值，就像在使用可选属性之前检查一样，我们需要使用缩小来检查可能的值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSome</span>(<span class="params">x: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;x is null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;x is string&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(x.length);</span><br><span class="line">        <span class="built_in">console</span>.log(x.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非空断言运算符 (<code>!</code> 后缀)</p><ul><li><code>ts</code> 的特殊语法，可以在不进行任何显式检查下，使用值</li><li><code>!</code> 在任何表达式之后写入实际上是一种类型断言，表示该值 我知道它由于某种原因它不是 <code>null</code> 或 <code>undefined</code></li><li>就像类型断言一样，它不会更改代码的运行时行为，因此仅当你知道它不是 <code>null</code> 或 <code>undefined</code> 时才应该使用非空断言运算符，这才是重要的</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">liveDangerous</span>(<span class="params">x?: <span class="built_in">number</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x!.toFixed(<span class="number">2</span>)); <span class="comment">// 我知道 x 是 number 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="枚举">枚举</h3><ol><li>枚举是 <code>ts</code> 添加到 <code>js</code> 中的一个功能，它允许描述一个值，该值是一组可能的命名常量之一。</li><li>关于枚举更深层次的使用</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="number">1</span>,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Direction.Up); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Direction.Down); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Up&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Down&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Left&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    Direction[Direction[<span class="string">&quot;Right&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(Direction.Up);</span><br><span class="line"><span class="built_in">console</span>.log(Direction.Down);</span><br></pre></td></tr></table></figure><h3 id="不太常见的原语">不太常见的原语</h3><h4 id="bigint"><code>bigint</code></h4><ol><li>从 <code>es2020</code> 开始，<code>js</code> 中有一个用来表示非常大的整数的原语 <code>BigInt</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bigNumber1: bigint = <span class="built_in">BigInt</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">let</span> bigNumber2: bigint = <span class="number">100n</span>;</span><br></pre></td></tr></table></figure><h4 id="symbol"><code>symbol</code></h4><ol><li><code>Symbol</code> 用来通过函数创建全局唯一引用</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy1: symbol = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sy2: symbol = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sy3 = <span class="built_in">Symbol</span>(<span class="string">&quot;ooo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sy4 = <span class="built_in">Symbol</span>(<span class="string">&quot;ooo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sy5 = <span class="built_in">Symbol</span>(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> sy6 = <span class="built_in">Symbol</span>(<span class="string">&quot;222&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sy1 === sy2) &#123;</span><br><span class="line">    <span class="comment">// 虽然这里也永远无法执行 但它不会报错</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">11111</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sy3 === sy4) &#123;</span><br><span class="line">    <span class="comment">// 虽然这里也永远无法执行 但它不会报错</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">22222</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sy5 === sy6) &#123; <span class="comment">// error</span></span><br><span class="line">    <span class="comment">// 永远不会执行，因为此条件始终返回 `false`  因为类型 typeof sy1 和 typeof sy2 没有重叠</span></span><br><span class="line">    <span class="comment">// 这是不是和文字类型比较类似了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型缩小">类型缩小</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    reurn <span class="keyword">new</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + input; <span class="comment">// error</span></span><br><span class="line">    <span class="comment">// 运算符 + 不能应用于类型 string | number</span></span><br><span class="line">    <span class="comment">// 我们没有明确检查 padding 是否为 `number` 也没有处理它是 string 的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型缩小</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这看起来和无聊的 JS 一样，但是 `TS` 的类型主旨在于编写典型的 `JS` 代码尽可能容易，而不需要弯腰去获取类型安全</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TS 使用静态类型分析运行的值一样，它在 JS 的运行时控制流构造上构造叠加了类型分析 </span></span><br><span class="line"><span class="comment">if else 三元运算 循环 真值 等 这些都会影响到这些类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在使用 typeof padding === &quot;number&quot; 时可以理解为一种特殊形式的代码，称为类型保护</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TS 遵循程序可能采取的执行路径，来分析一个值在特定位置的最具体的可能类型</span></span><br><span class="line"><span class="comment">它查看这些特殊的检查和赋值，将类型细化为比声明更具体的类型的过程称为缩小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">那么主要有以下几种缩小</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="typeof-类型守卫"><code>typeof</code> 类型守卫</h3><ol><li><code>typeof</code> 和 <code>js</code> 运算符一样，它可以提供有关我们运行时拥有的值类型的非常基本的信息。<code>ts</code> 期望它返回一组特定的字符串<ul><li><code>string</code></li><li><code>number</code></li><li><code>bigint</code></li><li><code>boolean</code></li><li><code>symbol</code></li><li><code>undefined</code></li><li><code>object</code></li><li><code>function</code></li></ul></li><li>在 <code>TS</code> 使用 <code>typeof</code> 可以理解为，它缩小在不同分支中的类型</li><li>在 <code>typescript</code> 中检查 <code>typeof</code> 的返回值是一种类型保护</li><li>注意 <code>typeof</code> 不返回字符串 <code>null</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123; <span class="comment">// error 因为 它可能是 null</span></span><br><span class="line">            <span class="built_in">console</span>.log(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(strs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真值缩小">真值缩小</h3><ol><li><p>真值检查通常在 <code>js</code> 我们也会这样做: <code>&amp;&amp;</code> <code>||</code> <code>if</code> <code>!</code> 等表达式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonCount</span>(<span class="params">count: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`There are <span class="subst">$&#123;count&#125;</span> people`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;There are no people&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样通过 <code>if</code> 语句将它们的条件强制转化为 <code>boolean</code> 使它有意义，然后根据结果是 <code>true</code> <code>false</code> 来选择它们的分支</p></li><li><p>下面这些值将会强制转换为 <code>false</code>。其他值被转换为 <code>true</code>，你始终可以在 <code>Boolean</code> 函数中运行值获得 <code>boolean</code> 或使用较短的双布尔否定将值强制转换为 <code>boolean</code>，当然双重否定的优点在于 <code>ts</code> 将它推断为一个 <code>true</code> 的文字类型 比较狭窄 而 <code>Boolean</code> 是一个 <code>boolean</code> 类型</p><ul><li><code>0</code></li><li><code>NaN</code></li><li><code>&quot;&quot;</code></li><li><code>0n</code></li><li><code>null</code></li><li><code>undefined</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// boolean</span></span><br><span class="line">!!<span class="string">&quot;1&quot;</span>; <span class="comment">// true 类型</span></span><br></pre></td></tr></table></figure></li><li><p>利用真值缩小可以防范于 <code>null</code> <code>undefined</code> 之类的值的影响</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs &amp;&amp; <span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(strs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是对原语的真值检查通常容易出错</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这样排除了 空字符串和 null</span></span><br><span class="line">    <span class="keyword">if</span> (strs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(strs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个真值缩小的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyAll</span>(<span class="params">values: <span class="built_in">number</span>[] | <span class="literal">undefined</span>, factor: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!values) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> values.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * factor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="等值缩小">等值缩小</h3><ol><li><p>使用 <code>===</code> <code>!==</code> <code>!=</code> <code>==</code> 等值检查来实现类型缩小，叫等值缩小</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span>, y: <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">        <span class="comment">// 我们可以确定 x 和 y 具有相同的类型 string</span></span><br><span class="line">        x.toUpperCase(); <span class="comment">// 因为 x 和 y 具有相同的类型 所以可以调用 toUpperCase()</span></span><br><span class="line">        y.toUpperCase(); <span class="comment">// 因为 x 和 y 具有相同的类型 所以可以调用 toUpperCase()</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">        <span class="built_in">console</span>.log(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在真值缩小中我们使用了一个不完善的缩小从而将空字符串从其中排除掉了，那么我们可以使用等值缩小进行完善</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(strs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>js</code> 更宽松的相等性检查 <code>==</code> <code>!=</code> 也能正确缩小。如果要检查一个变量是否等于 <code>null</code> 或 <code>undefined</code> 那么使用 <code>!=</code> 或 <code>==</code> 是一个好的方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Container &#123;</span><br><span class="line">    value: <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyValue</span>(<span class="params">container: Container, factor: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (container != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(container.value);</span><br><span class="line">        container.value *= factor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="in-操作符缩小"><code>in</code> 操作符缩小</h3><ol><li><p><code>in</code> 运算符，用于确定对象是否拥有某个名称的属性</p></li><li><p><code>value in x</code> <code>value</code> 是字符串文字，<code>x</code> 是类型，值为 <code>true</code> 的分支缩小，需要 <code>x</code> 具有可选或必需属性的类型的值，值为 <code>false</code> 的分支缩小，需要具有可选或缺失属性的值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fish = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> Bird = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">animal: Fish | Bird</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">        <span class="keyword">return</span> animal.swim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> animal.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human = &#123; swim?: <span class="function">() =&gt;</span> <span class="built_in">void</span>; fly?: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move1</span>(<span class="params">animal: Human | Fish | Bird</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">        <span class="comment">// Fish Human</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;fly&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">        <span class="comment">// Bird Human</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="instanceof-操作符缩小"><code>instanceof</code> 操作符缩小</h3><ol><li><code>instanceof</code> 检查一个值是否是另一个值的实例。更具体的 <code>x instanceof Foo</code> 检查 <code>x</code> 的原型链中是否含有 <code>Foo.prototype</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logValue</span>(<span class="params">x: <span class="built_in">Date</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x.toUTCString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分配缩小">分配缩小</h3><ol><li><p>我们在为任何变量赋值时，<code>TypeScript</code> 会查看赋值的右侧并适当缩小左侧</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ? <span class="number">10</span> : <span class="string">&quot;hello world&quot;</span>; <span class="comment">// string | number</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;goodbye&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line">x = <span class="literal">false</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p>注意，这些分配中的每一个都是有效的，即使在我们第一次赋值后观察到 <code>x</code> 更改为 <code>number</code> 我们仍然可以将 <code>string</code> 赋值给 <code>x</code> ，这是因为 <code>x</code> 在声明时是 <code>string | number</code></p></li></ol><h3 id="控制流分析">控制流分析</h3><ol><li>通过分析代码流程进行缩小类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// padding是数字的情况下，下面这行代码不会执行 所以这里只能是类型 string 这就是 控制流分析</span></span><br><span class="line">    <span class="keyword">return</span> padding + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用类型谓词">使用类型谓词</h3><ol><li><p>为了定义一个用户定义的类型保护，我们需要定义一个函数，其返回类型是一个类型谓词</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fish = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    swim: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bird = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    fly: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (pet <span class="keyword">as</span> Fish).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pet is Fish 是类型谓词 形式是 `parameterName is Type` 其中 `parameterName` 是一个形式参数的名称，`Type` 是一个类型名称</span></span><br><span class="line"><span class="comment">// 任何时候 isFish 被调用时，如果原始类型是兼容的，`ts` 将把变量缩小到该特定类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fish: Fish = &#123;</span><br><span class="line">        name: <span class="string">&quot;gold fish&quot;</span>,</span><br><span class="line">        swim: <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bird: Bird = &#123;</span><br><span class="line">        name: <span class="string">&quot;bird&quot;</span>,</span><br><span class="line">        fly: <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> ? bird : fish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> underWater1: Fish[] = zoo.filter(isFish);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// const underWater1: Fish[] = zoo.filter(isFish) as Fish[];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> underWater2: Fish[] = zoo.filter((pet): pet is Fish =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (pet.name === <span class="string">&quot;frog&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isFish(pet);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="受歧视的-unions">受歧视的 <code>unions</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    kind: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">    radius?: <span class="built_in">number</span>;</span><br><span class="line">    sideLength?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shape.kind === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 依然不可以直接使用 radius 因为它是可选的</span></span><br><span class="line">        <span class="comment">// 但实际上我们知道 kind 是 circle 时，一定有 radius，这样要么使用 非空断言 要么 使用类型保护</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius! ** <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shape.sideLength! ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但实际上是不理想的，理想的状态应该是 kind 是 `circle` 一定有 `radius` 是 `square` 一定有边长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们需要将 <code>Shape</code> 分成两种类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle = &#123;</span><br><span class="line">    kind: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square = &#123;</span><br><span class="line">    kind: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Circle | Square;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shape.kind === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius ** <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shape.sideLength ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就摆脱了错误</span></span><br></pre></td></tr></table></figure><ol><li>当联合类型中的每个类型都包含一个与文字类型相同的属性时，<code>ts</code> 认为这是一个有区别的联合类型，并且可以缩小联合类型的成员</li><li>上面的例子 <code>kind</code> 是公共成员，检查 <code>kind</code> 是 <code>circle</code> 就可以剔除 <code>Shape</code> 中所没有 <code>circle</code> 类型属性的类型，同样的检查也适用于 <code>switch</code> 语句</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius ** <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> shape.sideLength ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="never-类型与穷尽性检查"><code>never</code> 类型与穷尽性检查</h3><ol><li><p>在缩小范围中，可以将一个联合体的选项减少到已经删掉了所有可能性并且什么都不剩的程度，在这种情况下，我们可以将其称为 <code>never</code> 类型 不存在的状态</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius ** <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> shape.sideLength ** <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">const</span> _exhaustiveCheck: <span class="built_in">never</span> = shape;</span><br><span class="line">            <span class="keyword">return</span> _exhaustiveCheck;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="函数更多">函数更多</h2><p>函数是任何程序的基本构件</p><h3 id="函数类型表达式">函数类型表达式</h3><ol><li>描述一个函数的最简单的方法就是用一个函数类型表达式。这些类型在语法上类似于箭头函数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">fn: (a: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    fn(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printToConsole</span>(<span class="params">s: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greeter(printToConsole);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn: (a: string) =&gt; void 一个string 参数的函数 没有返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然我们也可以使用一个类型来命名一个函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GreetFunction = <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">fn: GreetFunction</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用签名">调用签名</h3><ol><li>在 <code>js</code> 中，函数除了可以调用以外，还可以拥有属性。然后，函数类型表达式的语法不允许声明属性。如果我们想用属性来描述可调用的东西，我们可以在一个对象类型中写入一个调用签名</li><li>注意，和函数类型表达式相比，语法略有不同：在参数列表和返回类型之间使用 <code>:</code> 而不是 <code>=&gt;</code></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DescriptionFunction = &#123;</span><br><span class="line">    description: <span class="built_in">string</span>;</span><br><span class="line">    (num: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">fn: DescriptionFunction</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">num: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.description = <span class="string">&quot;1111&quot;</span>;</span><br><span class="line"></span><br><span class="line">isOdd(fn);</span><br></pre></td></tr></table></figure><h3 id="构造签名">构造签名</h3><ol><li><p><code>js</code> 函数也可以使用 <code>new</code> 操作符来调用，<code>typescript</code> 称为构造函数，它们通常会创建一个新的对象，你可以通过在调用签名前面添加 <code>new</code> 关键字来写一个构造签名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ctor</span> </span>&#123;</span><br><span class="line">    s: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">s: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SomeConstructor = &#123;</span><br><span class="line">    <span class="keyword">new</span> (s: <span class="built_in">string</span>): Ctor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">ctor: SomeConstructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = fn(Ctor);</span><br><span class="line"><span class="built_in">console</span>.log(f.s);</span><br></pre></td></tr></table></figure></li><li><p>还有些对象，如 <code>Date</code> 对象，可以在有 <code>new</code> 或没有 <code>new</code> 的情况下被调用，那么可以在同一类型中结合调用签名和构造签名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> DateFunction &#123;</span><br><span class="line">    <span class="keyword">new</span> (s: <span class="built_in">string</span>): <span class="built_in">Date</span>;</span><br><span class="line">    (t: <span class="built_in">number</span>): <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDate</span>(<span class="params">fn: DateFunction</span>): <span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">new</span> fn(<span class="string">&quot;2024-12-10&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> t = fn(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, <span class="attr">minute</span>: <span class="built_in">number</span>): ClockInerface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInerface &#123;</span><br><span class="line">    tick(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    ctor: ClockConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">    hour: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    minute: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ClockInerface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigitalClock</span> <span class="title">implements</span> <span class="title">ClockInerface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;beep beep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnalogClock</span> <span class="title">implements</span> <span class="title">ClockInerface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;tick tock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> c2 = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">c1.tick();</span><br><span class="line">c2.tick();</span><br></pre></td></tr></table></figure></li></ol><h3 id="泛型函数">泛型函数</h3><ol><li><p>在写一个函数时，输入的类型与输出的类型有关，或者两个输入的类型以某中方式相关，那么就可以使用泛型函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstElement</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstElement1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr: T[]</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstElemet([]));</span><br><span class="line"><span class="built_in">console</span>.log(firstElemet([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(firstElemet([<span class="string">&quot;str1&quot;</span>]));</span><br></pre></td></tr></table></figure></li></ol><h4 id="类型推断">类型推断</h4><ol><li>在上面的例子中我们没有指定类型，类型是由 <code>ts</code> 自动推断出来的，当然也可以使用多个类型参数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">Input</span>, <span class="title">Output</span>&gt;(<span class="params">arr: Input[], func: (arg: Input) =&gt; Output</span>): <span class="title">Output</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parsed = map([<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>], <span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">parseInt</span>(n));</span><br></pre></td></tr></table></figure><h4 id="限制条件">限制条件</h4><ol><li><p>我们可以对任何类型的值进行操作，有时我们想把两个值联系起来，但只能对某个值的子集进行操作，在这种情况下，我们可以使用一个约束条件来限制一个类型参数可以接受的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longest</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123; length: <span class="built_in">number</span> &#125;&gt;(a: T, <span class="attr">b</span>: T) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt;= b.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(longest([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(longest(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world123&quot;</span>));</span><br><span class="line">longest(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p>在上面的例子中，有一些有趣的事情需要注意，我们允许 <code>Ts</code> 推断 <code>longest</code> 的返回类型，返回类型推断也适用于通用函数，我们将 <code>T</code> 约束为 <code>&#123; length: number &#125;</code>，所以我们才可以访问 <code>a</code> <code>b</code> 两个参数的 <code>.length</code> 属性，如果没有类型约束，我们不可以访问这些属性，因为这些值可能是一些没有长度属性的其他类型</p></li><li><p><code>Array</code> <code>string</code> 的类型是根据参数推断出来的，所以泛型就是把两个或多个具有相同类型的值联系起来</p></li><li><p>最后，正如我们希望的，<code>longest(10, 20)</code> 会报错，因为数字类型没有 <code>.length</code> 属性</p></li></ol><h4 id="使用受限值">使用受限值</h4><ol><li><p>这里有一个适用通用约束条件的常见错误</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minimumLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123; length: <span class="built_in">number</span> &#125;&gt;(obj: T, <span class="attr">minimum</span>: <span class="built_in">number</span>): T &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.length &gt;= minimum) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">length</span>: minimum &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>看起来上面的函数是没有问题的，<code>T</code> 被限制为 <code>&#123; length: number &#125;</code>，而且这个函数要么返回 <code>T</code> 要么返回一个与该限制相匹配的值，问题是，该函数承诺返回与传入参数相同的类型，而不仅仅是和约束条件想匹配的对象，如果这段代码是合法的，那么你可以得到这样一个无法工作的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = minimumLength([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li></ol><h4 id="指定类型参数">指定类型参数</h4><ol><li><p><code>TS</code> 通常可以推断出通用调用中的预期类型参数，但并非总是如此</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr1: T[], arr2: T[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr1.concat(arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = combine([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]); <span class="comment">// error 因为T首先被推断为 number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你非要这样做 指定类型参数是有必要的</span></span><br><span class="line"><span class="keyword">const</span> arr1 = combine&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure></li></ol><h4 id="编写优秀通用函数的准则">编写优秀通用函数的准则</h4><p>编写泛型函数很有趣，但是很容易被类型参数所迷惑，有太多的类型参数或在不需要的地方使用约束会使推理不那么成功</p><ol><li><p>类型参数下推</p><ul><li>规则: 在可能的情况下，使用类型参数本身，而不是对其进行约束</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstElement1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr: T[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstElement2</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">any</span>[]&gt;(<span class="params">arr: T</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个函数推断返回类型是 T 而第二个函数推断返回 any</span></span><br><span class="line"><span class="comment">// 因为 ts 必须使用约束类型来解析 arr[0] 表达式，而不是在调用期间 等待解析该元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = firstElement1([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// number</span></span><br><span class="line"><span class="keyword">let</span> b = firstElement2([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// any</span></span><br></pre></td></tr></table></figure></li><li><p>使用更少的类型参数</p><ul><li>规则: 总是尽可能少的使用类型参数</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr: T[], func: (arg: T) =&gt; <span class="built_in">boolean</span></span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种形式除了让函数更难看懂，没有任何用处</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter2</span>&lt;<span class="title">T</span>, <span class="title">Func</span> <span class="title">extends</span> (<span class="params">arg: T</span>) =&gt; <span class="title">boolean</span>&gt;(<span class="params">arr: T[], fn: Func</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型参数应出现两次</p><ul><li>规则: 如果一个类型的参数只出现在一个地方，请重新考虑是否真的需要</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>&lt;<span class="title">Str</span> <span class="title">extends</span> <span class="title">string</span>&gt;(<span class="params">s: Str</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello, &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么不直接使用 string 类型呢 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">s: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello, &quot;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="可选参数">可选参数</h3><ol><li><p><code>js</code> 中的函数经常需要一个可变数量的参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n.toFixed()); <span class="comment">// 0 个参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(n.toFixed(<span class="number">1</span>)); <span class="comment">// 1 个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1(); <span class="comment">// 正确</span></span><br><span class="line">fn1(<span class="number">10</span>); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>上面 <code>fn1</code> 函数参数 <code>x</code> 虽然指定为 <code>number</code> 但因为它是可选参数，所以它实际上具有 <code>number | undefined</code> 类型</p></li><li><p>也可以提供默认参数值，现在 <code>fn1</code> 的主体中，<code>x</code> 将具有 <code>number</code> 类型，因为任何 <code>undefined</code> 类型都会被替换为 <code>10</code></p></li><li><p>请注意，当一个参数是可选的，调用者总是可以传递未定义的参数，因为这只是模拟一个丢失的参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x?: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line">f();</span><br><span class="line">f(<span class="number">10</span>);</span><br><span class="line">f(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="回调中的可选参数">回调中的可选参数</h4><ol><li><p>一旦了解可选参数和函数类型表达式，在编写调用回调的函数时就很容易犯错</p></li><li><p>规则: 当为回调写一个函数类型时，永远不要写一个可选参数，除非你打算在不传递该参数的情况下它还可以工作</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        callback(arr[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在书写 index? 作为一个可选参数时，通常是想让这些调用是合法的</span></span><br><span class="line">myForEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="built_in">console</span>.log(a));</span><br><span class="line">myForEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> <span class="built_in">console</span>.log(a, i));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可是，如果调用者不想提供索引，并且回调中使用索引, 那么就会出现错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        callback(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myForEach([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i.toFixed()); <span class="comment">// error 因为 i 可能是 undefined 所以要让它不报错，要么你确定它一定有值使用非空断言 或者使用类型缩小</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数重载">函数重载</h3><ol><li><p>当一些函数可以在不同的参数数量和类型中被调用，可以通过编写重载签名来指定一个可以不同方式调用的函数，要做到这一点，要写一些数量的函数签名(通常是两个或多个)，然后是函数的主体</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDate</span>(<span class="params">timestamp: <span class="built_in">number</span></span>): <span class="title">Date</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDate</span>(<span class="params">m: <span class="built_in">number</span>, d: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">Date</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDate</span>(<span class="params">mOrTimestamp: <span class="built_in">number</span>, d?: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d !== <span class="literal">undefined</span> &amp;&amp; y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(y, mOrTimestamp, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(mOrTimestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeDate(<span class="number">12345678</span>);</span><br><span class="line">makeDate(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2024</span>);</span><br><span class="line">makeDate(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li><li><p>这里我们写了两个重载: 一个接受一个参数，另一个接受三个参数。前两个签名被称为重载签名，然后我们写了一个具有兼容签名的函数实现。函数有一个实现签名，但是这个签名不能被直接调用。即使我们写了一个所需参数之后有两个可选的参数，但是也不能以两个参数调用</p></li></ol><h4 id="重载签名和实现签名">重载签名和实现签名</h4><ol><li><p>这是一个常见的混乱来源</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望以零参数调用</span></span><br><span class="line"><span class="comment">// 但是错误，提示未提供 x 变量</span></span><br><span class="line">fn(); <span class="comment">// error</span></span><br><span class="line">fn(<span class="number">10</span>); <span class="comment">// 所以只能这样调用，那么这样使用重载签名的意义何在</span></span><br></pre></td></tr></table></figure></li><li><p>用于编写函数体的签名不能从外面看到</p><ul><li>实现的签名从外面是看不到的，在编写重载函数时，应该总是在函数的实现上有两个或两个以上的重载签名</li></ul></li><li><p>实现签名也必须与重载签名兼容</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">boolean</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">void</span></span>; <span class="comment">// error string boolean 不兼容 实现签名是 boolean 而 重载签名是 string 所以实现签名必须使用 联合类型才对</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">boolean</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>; <span class="comment">// 返回类型不兼容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">boolean</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ops&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="编写好的重载">编写好的重载</h4><ol><li><p>和泛型一样，在使用函数重载时，有一些准则需要遵循</p><ul><li>在可能的情况下，总是倾向于使用联合类型的参数而不是重载参数</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">s: <span class="built_in">any</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">x: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">len(<span class="string">&quot;srt&quot;</span>);</span><br><span class="line">len([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">len(<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">&quot;str&quot;</span> : [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的实现签名是兼容的</span></span><br><span class="line"><span class="comment">// 我们可以使用 字符串或数组来调用它</span></span><br><span class="line"><span class="comment">// 但是我们不能使用可能是字符串或数组的值来调用它，因为 ts 只能将一个函数调用解析为一个重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为两个重载都有相同的参数数量和相同的返回类型，可以改写为</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">x: <span class="built_in">any</span>[] | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">len(<span class="string">&quot;srt&quot;</span>);</span><br><span class="line">len([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">len(<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="string">&quot;str&quot;</span> : [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure></li></ol><h4 id="函数内-This-的声明">函数内 <code>This</code> 的声明</h4><ol><li><p><code>TypeScript</code> 会通过代码流分析来推断函数中的 <code>this</code> 应该是什么</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    id: <span class="number">123</span>,</span><br><span class="line">    admin: <span class="literal">false</span>,</span><br><span class="line">    becomeAdmin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.admin = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts 理解函数 user.becomeAdmin 有一个对应的 this 它是外部对象 user，这个对于很多情况下已经足够了，但是在某些情况下，我们需要明确的指定函数中的 this 类型</span></span><br><span class="line"><span class="comment">// js 规范中，不能有一个叫 `this` 的参数，所以 TypeScript 使用这个语法空间，让你在函数体中声明 this 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    admin: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> DB &#123;</span><br><span class="line">    filterUsers(filter: <span class="function">(<span class="params"><span class="built_in">this</span>: User</span>) =&gt;</span> <span class="built_in">boolean</span>): User[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db:DB = &#123;</span><br><span class="line">    filterUsers: <span class="function">(<span class="params">filter: (<span class="built_in">this</span>: User) =&gt; <span class="built_in">boolean</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> user1 = &#123;</span><br><span class="line">            admin: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> user2 = &#123;</span><br><span class="line">            admin: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [user1, user2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> admins = db.filterUsers(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">this</span>: User</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.admin;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是注意，需要使用函数而不是箭头函数</span></span><br><span class="line"><span class="keyword">const</span> admins1 = db.filterUsers(<span class="function">() =&gt;</span> <span class="built_in">this</span>.admin); <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="需要了解的其他类型">需要了解的其他类型</h3><ol><li>一些函数的上下文中特别相关的类型</li></ol><h4 id="void"><code>void</code></h4><ol><li><p><code>void</code> 表示没有返回值的函数的返回值。当一个函数没有任何返回语句，或者没有从这些返回语句中返回任何明确的值时，它都是推断出来的类型</p></li><li><p>在 <code>js</code> 中，一个不返回任何值的函数将隐含的返回 <code>undefined</code> 的值，然而在 <code>ts</code> 中，<code>void</code> 和 <code>undefined</code> 是不一样的</p></li><li><p>记住 <code>void</code> 和 <code>undefined</code> 不一样</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断返回的类型是 void</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="object"><code>object</code></h4><ol><li>特殊类型 <code>object</code> 指的是任何不是基元的值 <code>string</code> <code>number</code> <code>bigint</code> <code>boolean</code> <code>symbol</code> <code>null</code> <code>undefined</code> 之外的。这和空对象类型 <code>&#123;&#125;</code> 不同，也与全局类型 <code>Object</code> 不同。你可能永远不会使用到 <code>Object</code></li><li><code>object</code> 不是 <code>Object</code> 始终使用 <code>object</code></li><li>注意：在 <code>js</code> 中，函数是对象，它们有属性，在它们的原型链上有 <code>Object.prototype</code>，是 <code>object</code> 的实例，可以对它们调用 <code>Object.keys</code>等。由于这些原因，函数类型在 <code>Typescript</code> 中被认为是 <code>object</code></li></ol><h4 id="unknown"><code>unknown</code></h4><ol><li><code>unknown</code> 类型代表任何值，这和 <code>any</code> 类型类似，但是更安全，因为对未知 <code>unknown</code> 值做任何事情都是不合法的</li><li>这对于描述函数类型非常有用，因为你可以描述接受任何值的函数，而不需要在函数体有 <code>any</code> 值。反之，你可以描述一个返回未知类型的值的函数</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    a.b(); <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">a: unknown</span>) </span>&#123;</span><br><span class="line">    a.b(); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeParse</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = safeParse(<span class="string">&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;</span>); <span class="comment">// 要小心对待 obj</span></span><br></pre></td></tr></table></figure><h4 id="never"><code>never</code></h4><ol><li>有些函数永远不会返回一个值</li><li><code>never</code> 类型表示永远不会被观察到的值，在一个返回类型中，这意味着函数抛出一个异常或终止程序的执行</li><li><code>never</code> 也出现在 <code>TypeScript</code> 确定一个 <code>union</code> 中没有任何东西的时候</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x; <span class="comment">// never 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Function"><code>Function</code></h4><p>全局性的 <code>Function</code> 类型描述了诸如 <code>bind</code> <code>call</code> <code>apply</code> 和其他存在于 <code>JS</code> 中所有函数值的属性。它还有一个特殊的属性。即 <code>Function</code> 类型的值总是可以被调用，这些调用返回 <code>any</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个无类型的函数调用，一般来说最好避免，因为 any 返回类型都不安全</span></span><br><span class="line"><span class="comment">// 如果你需要接受一个任意的函数，但不打算调用它，一般来说 () =&gt; void 是安全的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">f: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数展开运算符">参数展开运算符</h3><h4 id="形参展开">形参展开</h4><ol><li>除了使用可选参数或重载来制作可以接受各种固定参数数量的函数外，还可以使用休止参数来定义接受无限制数量参数的函数</li><li><code>rest</code> 参数出现在所有其他参数之后，并使用 <code>...</code> 语法</li><li>在 <code>ts</code> 中，这些参数的类型注解是隐含的 <code>any[]</code> 而不是 <code>any</code>，任何给出的类型注解必须是 <code>Array&lt;T&gt;</code> 或 <code>T[]</code> 的形式，或一个元组类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mulitiply</span>(<span class="params">n: <span class="built_in">number</span>, ...m: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.map(<span class="function">(<span class="params">x</span>) =&gt;</span> n * x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = mulitiply(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="实参展开">实参展开</h4><ol><li><p>反之，我们可以使用 <code>spread</code> 语法从数组中提供可变数量的参数，例如，数组的 <code>push</code> 方法需要任意数量的参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure></li><li><p>请注意，一般来说 <code>TS</code> 并不假定数组是不可变的，这可能会导致一些意想不到的行为</p></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> angle = <span class="built_in">Math</span>.atan2(...args); <span class="comment">// error 它不认为 args的数量是两个即使使用了 const 进行定义 除非使用 as const</span></span><br></pre></td></tr></table></figure><h3 id="参数解构">参数解构</h3><ol><li><p>可以使用参数重构来方便的将作为参数提供的对象，解压到函数主体的一个或多个局部变量中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">&#123; a, b, c &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(&#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的类型注解在解构的语法之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">&#123; a, b, c &#125;: &#123; a: <span class="built_in">number</span>; b: <span class="built_in">number</span>; c: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ABC = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; b: <span class="built_in">number</span>; c: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">&#123; a, b, c &#125;: ABC</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数的可分配性">函数的可分配性</h3><h4 id="返回-void-类型">返回 <code>void</code> 类型</h4><ol><li>函数的 <code>void</code> 返回类型可以产生一些不同寻常的行为，但却是预期的行为</li><li>返回类型 <code>void</code> 的上下文类型并不强迫函数不返回东西。另一种说法是，一个具有 <code>void</code> 返回类型的上下文函数类型 ( <code>type vf = () =&gt; void</code>)，在实现时，可以返回任何其他的值，但它会被忽略，因此，以下 <code>() =&gt; void</code> 类型的实现是有效的</li><li>需要注意，当一个字面的函数定义返回类型是 <code>void</code>，该函数不能返回任何东西</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f1: voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f2: voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f3: voidFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当这些函数之一的返回值被分配给另一个变量时，它将保留 void 类型</span></span><br><span class="line"><span class="keyword">const</span> v1 = f1();</span><br><span class="line"><span class="keyword">const</span> v2 = f2();</span><br><span class="line"><span class="keyword">const</span> v3 = f3();</span><br></pre></td></tr></table></figure><h2 id="对象类型-2">对象类型</h2><ol><li><p>在 <code>js</code> 中，我们分组和传递数据的基本方式是通过对象，我们通过对象类型来表示这些对象</p></li><li><p>对象类型可以是匿名的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + person.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + person.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者类型别名</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + person.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="属性修改器">属性修改器</h3><ol><li>对象类型中的每个属性都可以指定几件事: 类型、属性是否可选，以及属性是否可以被写入</li></ol><h4 id="可选属性-2">可选属性</h4><ol><li>在属性后使用 <code>?</code> 表示它是可选的</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PaintOptions &#123;</span><br><span class="line">    shape: Shape;</span><br><span class="line">    xPos?: <span class="built_in">number</span>;</span><br><span class="line">    yPos?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintShape</span>(<span class="params">opts: PaintOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shape: Shape = &#123;&#125;;</span><br><span class="line">paintShape(&#123; shape &#125;);</span><br><span class="line">paintShape(&#123; shape, <span class="attr">xPos</span>: <span class="number">100</span> &#125;);</span><br><span class="line">paintShape(&#123; shape, <span class="attr">yPos</span>: <span class="number">100</span> &#125;);</span><br><span class="line">paintShape(&#123; shape, <span class="attr">xPos</span>: <span class="number">100</span>, <span class="attr">yPos</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p>在 <code>js</code> 中，即使该属性从未被设置过，我们任然可以访问它-它只是为定义的值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintShape</span>(<span class="params">opts: PaintOptions</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xPos = opts.xPos || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> yPos = opts.yPos || <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这种未指定的值设置默认值非常普遍，以至于 <code>js</code> 有特殊的语法来支持它</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintShape</span>(<span class="params">&#123; shape, xPos = <span class="number">0</span>, yPos = <span class="number">0</span> &#125;: PaintOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 paintShape 的参数使用了解构，并未 x y提供了默认值，现在x,y肯定都</span></span><br><span class="line"><span class="comment"> * 存在于 paintShape 的主体中，但对于 `paintShape` 来说的任何调用者来说是可选的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：目前还没有办法将类型注释放在结构模式中，这是因为下面的语法在 js 中有了不同的含义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">&#123; shape: Shape, xPos: <span class="built_in">number</span> = <span class="number">100</span> &#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是将参数对象中的 shape 换成临时变量 Shape xPos 换成 number 标识符</span></span><br></pre></td></tr></table></figure><h4 id="只读属性">只读属性</h4><ol><li><p>对于 <code>TS</code> 属性可以被标记为只读，虽然它不会在运行时改变任何行为，但是在类型检查期间，一个标记为只读的属性不能被写入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SomeType &#123;</span><br><span class="line">    <span class="keyword">readonly</span> prop: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSome</span>(<span class="params">obj: SomeType</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.prop);</span><br><span class="line"></span><br><span class="line">    obj.prop = <span class="string">&quot;hello&quot;</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>readonly</code> 修饰符并不一定意味着一个值是完全不可改变的，或者换句话说，它的内部内容不能被改变，它只意味着该属性本身不能被重新写入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Home &#123;</span><br><span class="line">    <span class="keyword">readonly</span> resident: &#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        age: <span class="built_in">number</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visitForBirthday</span>(<span class="params">home: Home</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Happy $&#123;home.resident.age&#125; Birthday $&#123;home.resident.name&#125;&quot;</span>);</span><br><span class="line">    home.resident.age++; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evict</span>(<span class="params">home: Home</span>) </span>&#123;</span><br><span class="line">    home.resident = &#123;</span><br><span class="line">        name: <span class="string">&quot;Victor the Evictor&quot;</span>,</span><br><span class="line">        age: <span class="number">42</span>,</span><br><span class="line">    &#125;; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>管理对 <code>readonly</code> 含义的预期很重要，在 <code>ts</code> 开发中，对于一个对象应该如何被使用的问题，它是有用的信号。<code>ts</code> 在检查两个类型的属性是否兼容时，并不考虑这些类型的属性是否是 <code>readonly</code> 所以 <code>readonly</code> 属性也可以通过别名来改变</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ReadonlyPerson &#123;</span><br><span class="line">    <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> writeblePerson: Person = &#123;</span><br><span class="line">    name: <span class="string">&quot;Person McPersonface&quot;</span>,</span><br><span class="line">    age: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readonlyPerson: ReadonlyPerson = writeblePerson;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(readonlyPerson.age);</span><br><span class="line">writeblePerson.age++;</span><br><span class="line"><span class="built_in">console</span>.log(readonlyPerson.age);</span><br></pre></td></tr></table></figure></li></ol><h4 id="索引签名">索引签名</h4><ol><li><p>有时并不提前知道一个类型的所有属性名称，但知道值的形状，在这种情况下，可以使用索引签名来描述可能的值的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [index: number] 索引属性，表示当一个 StringArray 被数字索引时，返回一个字符串</span></span><br><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>];</span><br></pre></td></tr></table></figure></li><li><p>索引签名的属性类型必须是 <code>string</code> 或 <code>number</code></p></li><li><p>支持两种类型的索引器是可能的，但是从数字索引器返回的类型必须是字符串索引器返回的类型的子类型。这是因为当用 <code>number</code> 进行索引时，<code>js</code> 实际上会在索引到一个对象之前将其转换为 <code>string</code>。这意味着用 <code>100</code> 进行索引和用 <code>'100'</code> 进行索引是一样的，所以两者需要一致</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> NotOkay &#123;</span><br><span class="line">    [x: <span class="built_in">number</span>]: Animal; <span class="comment">// 错误 number 索引返回 Animal 而 string 索引返回 Dog, Animal 不是 Dog 的子类型</span></span><br><span class="line">    [x: <span class="built_in">string</span>]: Dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> YesKey &#123;</span><br><span class="line">    [x: <span class="built_in">number</span>]: Dog;</span><br><span class="line">    [x: <span class="built_in">string</span>]: Animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>虽然字符串索引签名是描述字典模式的一种强大方式，但它也强制要求所有的属性与它们的返回类型想匹配。这是因为字符串索引声明 <code>obj.proerty</code> 也可以作为 <code>obj[&quot;property&quot;]</code> 在下面的例子中，<code>name</code> 的类型与字符串索引的类型不匹配</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">    length: <span class="built_in">number</span>; <span class="comment">// ok</span></span><br><span class="line">    name: <span class="built_in">string</span>; <span class="comment">// error 类型 string 的属性不能赋值给 string 索引类型 number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然而，如果索引类型是属性类型的联合，不同类型的属性是可以接受的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberOrStringDictionary &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line">    length: <span class="built_in">number</span>; <span class="comment">// ok</span></span><br><span class="line">    name: <span class="built_in">string</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，索引签名也可以为只读属性，以防止对其索引的赋值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array: ReadonlyStringArray = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>];</span><br><span class="line">array[<span class="number">2</span>] = <span class="string">&quot;3&quot;</span>; <span class="comment">// error readonly</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="扩展类型">扩展类型</h3><ol><li><p>有些类型可能是其他类型的更具体的版本</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> BasicAddress &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    street: <span class="built_in">string</span>;</span><br><span class="line">    city: <span class="built_in">string</span>;</span><br><span class="line">    country: <span class="built_in">string</span>;</span><br><span class="line">    postalCode: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在需要一个地址的单元</span></span><br><span class="line"><span class="keyword">interface</span> AddressWithUnit <span class="keyword">extends</span> BasicAddress &#123;</span><br><span class="line">    unit: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口的 <code>extends</code> 关键字，允许我们有效地从其他命名的类型中复制成员，并添加我们想要的任何新成员，这对于减少重复非常有用，以及表明同一属性的几个不同声明可能是相关的意图来说，是非常有用的</p></li><li><p>接口也可以从多个类型中扩展</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Colorful &#123;</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ColorfulCircle <span class="keyword">extends</span> Colorful, Circle &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc: ColorfulCircle = &#123;</span><br><span class="line">    color: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    radius: <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="交叉类型">交叉类型</h3><ol><li><p>接口允许通过扩展其他类型建立新的类型。而交叉类型可以通过组合其他类型建立新的类型</p></li><li><p>交叉类型用 <code>&amp;</code> 操作符定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Colorful &#123;</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColorfulCircle = Colorful &amp; Circle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cc: ColorfulCircle = &#123;</span><br><span class="line">    color: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">    radius: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">circle: ColorfulCircle</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(circle.color);</span><br><span class="line">    <span class="built_in">console</span>.log(circle.radius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">draw(&#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">radius</span>: <span class="number">100</span> &#125;);</span><br><span class="line">draw(cc);</span><br></pre></td></tr></table></figure></li></ol><h3 id="接口与交叉类型">接口与交叉类型</h3><ol><li>接口扩展和交叉类型非常相似，但实际上有些细小的不同，对于接口，我们可以使用 <code>extends</code> 子句来扩展其他类型，而对于交叉类型，我们也可以做类似的事，并用类型别名来命名新类型。</li><li>两者之间的主要区别在于如何处理冲突，这种区别通常是在接口和交叉类型的类型别名之间选择的一个主要原因</li></ol><blockquote class="mindmap" style="height:400px;contenteditable:true"><ul><li>接口 VS. 交叉类型<ul><li>相同点<ul><li>都可以描述对象或函数</li><li>都可以扩展其他类型</li></ul></li><li>区别<ul><li>不同的声明范围<ul><li>接口: 声明中，值是具体结构对象</li><li>交叉: 可以为任意的类型创建类型别名</li></ul></li><li>不同的扩展形式<ul><li>接口: extends</li><li>交叉: &amp;</li></ul></li><li>不同的重复定义表现形式<ul><li>接口: 自动合并</li><li>交叉: 报错</li></ul></li></ul></li><li>如何选择<ul><li>建议优先选择接口</li><li>接口满足不了再使用交叉类型</li></ul></li></ul></li></ul></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口可以定义多次，多次的声明会自动合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Sister &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Sister &#123;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> si: Sister = &#123; <span class="comment">// error 缺少 age 属性</span></span><br><span class="line">    name: <span class="string">&quot;suxi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sis: Sister = &#123;</span><br><span class="line">    name: <span class="string">&quot;suxi&quot;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名定义多次会报错</span></span><br><span class="line"><span class="keyword">type</span> Sister = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sister = &#123; <span class="comment">// error 不可以重复定义类型</span></span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范型对象类型">范型对象类型</h3><ol><li><p>如果有一个包含任何数据的盒子类型: 字符串、数字、苹果</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// any</span></span><br><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">    contents: <span class="built_in">any</span>; <span class="comment">// any 但是ts的类型检查就失效了 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 unknown</span></span><br><span class="line"><span class="keyword">interface</span> Box &#123;</span><br><span class="line">    contents: unknown; <span class="comment">// 虽然安全，但是使用时需要进行类型缩小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> box: Box = &#123;</span><br><span class="line">    contents: <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> box.contents === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(box.contents.toUpperCase());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(box.contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每一个盒子搭建不同的类型</span></span><br><span class="line"><span class="keyword">interface</span> NumberBox &#123;</span><br><span class="line">    contents: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StringBox &#123;</span><br><span class="line">    contents: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> BooleanBox &#123;</span><br><span class="line">    contents: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但这也意味着我们必须创建不同的函数或函数的重载，对这些结构类似的类型进行操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setContents</span>(<span class="params">box: NumberBox, newContents: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setContetns</span>(<span class="params">box: StringBox, newContents: <span class="built_in">string</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setContents</span>(<span class="params">box: BooleanBox, newContents: <span class="built_in">boolean</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setContents</span>(<span class="params">box: &#123; contents: <span class="built_in">any</span> &#125;, newContents: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    box.contents = newContents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果以后需要引入更多类型的盒子，这是非常差劲的</span></span><br><span class="line"><span class="comment">// 相反我们可以做一个通用的 Box 类型，声明一个类型参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Box&lt;T&gt; &#123;</span><br><span class="line">    contents: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> box1 = Box&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">    contents: <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> box2 = Box&lt;<span class="built_in">boolean</span>&gt; = &#123;</span><br><span class="line">    contents: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 盒子是可重用的，因为 T 可以用任何东西来代替，这意味着当我们需要一个新类型的盒子时，我们根本不需要一个新的盒子类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Apple &#123;</span><br><span class="line">    weight: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> appleBox: Box&lt;Apple&gt; = &#123;</span><br><span class="line">    contents: &#123;</span><br><span class="line">        weight: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 意味着我们也可以完全避免重载，而使用通用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setContents</span>&lt;<span class="title">T</span>&gt;(<span class="params">box: Box&lt;T&gt;, contents: T</span>) </span>&#123;</span><br><span class="line">    box.contents = contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>值得注意的是，类型别名也可以通用的，我们可以通过使用类型别名来代替</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Box&lt;T&gt; = &#123;</span><br><span class="line">    contents: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于类型别名与接口不同，它不仅可以描述对象类型，还可以用它来编写其他类型的通用辅助类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OrNull&lt;T&gt; = T | <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">type</span> OneOrMany&lt;T&gt; = Type | Type[];</span><br><span class="line"><span class="keyword">type</span> OneOrManyOrNull&lt;T&gt; = orNull&lt;OneOrMany&lt;T&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> OneOrManyOrNullStrings = OneOrManyOrNull&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure></li><li><p>通用对象类型通常是某种容器类型，它的工作与它们所包含的元素类型无关。数据结构以这种形式工作是理想的，这样它们就可以在不同的数据类型中重复使用</p></li></ol><h3 id="数组类型">数组类型</h3><ol><li><p>我们一直在使用这样一种类型: 数组类型，<code>number[]</code> <code>string[]</code> 这种类型 实际上是 <code>Array&lt;number&gt;</code> 和 <code>Array&lt;string&gt;</code> 的缩写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSome</span>(<span class="params">value: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: <span class="built_in">string</span>[] = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hell&quot;</span>];</span><br><span class="line"></span><br><span class="line">doSome(myArray);</span><br></pre></td></tr></table></figure></li><li><p>和上面的 <code>Box</code> 类型一样，<code>Array</code> 本身也是一个通用类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Array&lt;T&gt; &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">    pop(): T | <span class="literal">undefined</span>;</span><br><span class="line">    push(...items: T[]): <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现代 <code>JS</code> 还提供了其他通用的数据结构，比如 <code>Map&lt;K, V&gt;</code> <code>Set&lt;T&gt;</code> <code>Promise&lt;T&gt;</code> 。这意味着，由于 <code>Map</code> <code>Set</code> <code>Promise</code> 的行为方式，它们可以与任何类型的集合一起工作</p></li></ol><h3 id="只读数组类型">只读数组类型</h3></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>typescript学习笔记</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://blog.keyiqingxin.cn/9f47fabe/">https://blog.keyiqingxin.cn/9f47fabe/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>可以清心</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-06-30</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-12-27</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener external nofollow noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener external nofollow noreferrer" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/typescript/">typescript</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.keyiqingxin.cn/cover/552320.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/social-share/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.keyiqingxin.cn/social-share/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.keyiqingxin.cn/wechat/wechat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.keyiqingxin.cn/wechat/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/ff44d7d9/"><img class="prev-cover" src="https://cdn.keyiqingxin.cn/cover/517950.jpg" onerror='onerror=null,src="https://cdn.keyiqingxin.cn/avatar/avatar1.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用TensorFlow.js进行人脸动作检测</div></div></a></div><div class="next-post pull-right"><a href="/7bfffe12/"><img class="next-cover" src="https://cdn.keyiqingxin.cn/cover/572885.jpg" onerror='onerror=null,src="https://cdn.keyiqingxin.cn/avatar/avatar1.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">十分钟理解Object.defineProperty</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">TypeScript 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TSC-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">TSC 编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-number">1.2.</span> <span class="toc-text">发出错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">显式类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%A6%E6%8B%AD%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">擦拭类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7%E7%BC%96%E8%AF%91"><span class="toc-number">1.5.</span> <span class="toc-text">降级编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">严格模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">常用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typescript"><span class="toc-number">2.1.</span> <span class="toc-text">typescript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%85%83%E7%B1%BB%E5%9E%8B-number-string-boolean"><span class="toc-number">2.2.</span> <span class="toc-text">基元类型 number string boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any"><span class="toc-number">2.4.</span> <span class="toc-text">any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8A%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A"><span class="toc-number">2.5.</span> <span class="toc-text">变量上的类型注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A"><span class="toc-number">2.6.1.</span> <span class="toc-text">参数类型注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A"><span class="toc-number">2.6.2.</span> <span class="toc-text">返回类型注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.3.</span> <span class="toc-text">匿名函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.1.</span> <span class="toc-text">可选属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.8.</span> <span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">2.9.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.10.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">2.10.1.</span> <span class="toc-text">接口和类型别名之间的差异</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">2.11.</span> <span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.12.</span> <span class="toc-text">文字类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%8E%A8%E7%90%86"><span class="toc-number">2.12.1.</span> <span class="toc-text">文字推理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-%E5%92%8C-undefined"><span class="toc-number">2.13.</span> <span class="toc-text">null 和 undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.14.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%A4%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="toc-number">2.15.</span> <span class="toc-text">不太常见的原语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bigint"><span class="toc-number">2.15.1.</span> <span class="toc-text">bigint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symbol"><span class="toc-number">2.15.2.</span> <span class="toc-text">symbol</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.</span> <span class="toc-text">类型缩小</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof-%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB"><span class="toc-number">3.1.</span> <span class="toc-text">typeof 类型守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%80%BC%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.2.</span> <span class="toc-text">真值缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.3.</span> <span class="toc-text">等值缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.4.</span> <span class="toc-text">in 操作符缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.5.</span> <span class="toc-text">instanceof 操作符缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%BC%A9%E5%B0%8F"><span class="toc-number">3.6.</span> <span class="toc-text">分配缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-number">3.7.</span> <span class="toc-text">控制流分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D"><span class="toc-number">3.8.</span> <span class="toc-text">使用类型谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E6%AD%A7%E8%A7%86%E7%9A%84-unions"><span class="toc-number">3.9.</span> <span class="toc-text">受歧视的 unions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%A9%B7%E5%B0%BD%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">3.10.</span> <span class="toc-text">never 类型与穷尽性检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9B%B4%E5%A4%9A"><span class="toc-number">4.</span> <span class="toc-text">函数更多</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">函数类型表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D"><span class="toc-number">4.2.</span> <span class="toc-text">调用签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-number">4.3.</span> <span class="toc-text">构造签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">泛型函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">4.4.1.</span> <span class="toc-text">类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.4.2.</span> <span class="toc-text">限制条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%97%E9%99%90%E5%80%BC"><span class="toc-number">4.4.3.</span> <span class="toc-text">使用受限值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.4.</span> <span class="toc-text">指定类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%BC%98%E7%A7%80%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">4.4.5.</span> <span class="toc-text">编写优秀通用函数的准则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">可选参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text">回调中的可选参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">4.6.</span> <span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%AD%BE%E5%90%8D%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">4.6.1.</span> <span class="toc-text">重载签名和实现签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">4.6.2.</span> <span class="toc-text">编写好的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%85-This-%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.6.3.</span> <span class="toc-text">函数内 This 的声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.7.</span> <span class="toc-text">需要了解的其他类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#void"><span class="toc-number">4.7.1.</span> <span class="toc-text">void</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object"><span class="toc-number">4.7.2.</span> <span class="toc-text">object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unknown"><span class="toc-number">4.7.3.</span> <span class="toc-text">unknown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#never"><span class="toc-number">4.7.4.</span> <span class="toc-text">never</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function"><span class="toc-number">4.7.5.</span> <span class="toc-text">Function</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.8.</span> <span class="toc-text">参数展开运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%B1%95%E5%BC%80"><span class="toc-number">4.8.1.</span> <span class="toc-text">形参展开</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E5%8F%82%E5%B1%95%E5%BC%80"><span class="toc-number">4.8.2.</span> <span class="toc-text">实参展开</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84"><span class="toc-number">4.9.</span> <span class="toc-text">参数解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E5%88%86%E9%85%8D%E6%80%A7"><span class="toc-number">4.10.</span> <span class="toc-text">函数的可分配性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-void-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.10.1.</span> <span class="toc-text">返回 void 类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">5.</span> <span class="toc-text">对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">属性修改器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7-2"><span class="toc-number">5.1.1.</span> <span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.2.</span> <span class="toc-text">只读属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">5.1.3.</span> <span class="toc-text">索引签名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">扩展类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">接口与交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">范型对象类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.</span> <span class="toc-text">数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.7.</span> <span class="toc-text">只读数组类型</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 可以清心</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="to_comment" type="button" title="直达评论" onclick="FixedCommentBtn()"><i class="fas fa-comments"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.keyiqingxin.cn/js/utils.js"></script><script src="https://cdn.keyiqingxin.cn/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.keyiqingxin.cn/snackbar/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.keyiqingxin.cn",region:""},null))},n=()=>{twikoo.getCommentsCount({envId:"https://twikoo.keyiqingxin.cn",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},e=(e=!1)=>{"object"==typeof twikoo?(o(),e&&t&&setTimeout(n,0)):getScript("https://cdn.keyiqingxin.cn/twikoo/twikoo.all.min.js").then(()=>{o(),e&&t&&setTimeout(n,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),e)})()</script><script>function loadWaline(){function n(){new Waline(Object.assign({el:"#waline-wrap",serverURL:"https://waline.keyiqingxin.cn",avatar:"monsterid",path:location.pathname,emojiCDN:"",emojiMaps:"",visitor:!1},{login:"enable"}))}"function"==typeof Waline?n():getScript("https://cdn.keyiqingxin.cn/waline/Waline.min.js").then(n)}{function loadOtherComment(){loadWaline()}}</script></div><div class="aplayer no-destroy" data-id="2495595989" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script async src="https://cdn.keyiqingxin.cn/js/font_2264842_3izu8i5eoc2.js"></script><script defer src="https://cdn.keyiqingxin.cn/live2d-widget/autoload.js"></script><script defer src="https://cdn.keyiqingxin.cn/js/live2dcubismcore.min.js"></script><script defer src="https://cdn.keyiqingxin.cn/js/asyncmodel.min.js"></script><script src="https://cdn.keyiqingxin.cn/twikoo/twikoo.all.min.js"></script><div id="live3d" class="live3d" style="position:fixed;left:-100px;bottom:-20px;width:500px!important;height:437.5px!important;z-index:98"><canvas id="live2dm" class="live3d"></canvas></div><script data-pjax defer src="https://cdn.keyiqingxin.cn/js/fixed_comment.js"></script><script data-pjax defer src="https://cdn.keyiqingxin.cn/js/comment_barrage.js"></script><script>let tianliGPT_postSelector="#post #article-container",tianliGPT_key="nHC6jHq3oJ4trKTHCPyn"</script><script src="https://cdn.keyiqingxin.cn/tianli_gpt/tianli-gpt.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.keyiqingxin.cn/butterfly-extsrc/fireworks.min.js"></script><script src="https://cdn.keyiqingxin.cn/butterfly-extsrc/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.keyiqingxin.cn/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.keyiqingxin.cn/aplayer/APlayer.min.js"></script><script src="https://cdn.keyiqingxin.cn/meting/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨空间站上新啦！ 👉</label><a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍭查看新品🍬</span></a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"✨ 空间站上新啦！ 👉",backgroundColor:t,duration:5e5,pos:e,actionText:"🍭查看新品🍬",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",(function(){showNotification()})),window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js")})))</script></div><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&"/"===location.pathname&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.keyiqingxin.cn/bdhistory/js/main.js"></script><script data-pjax>if(document.getElementById("recent-posts")&&"/"==location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/1111069.png" alt="https://cdn.keyiqingxin.cn/cover/1111069.png"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-09-17</span><a class="blog-slider__title" href="679887a0/">butterfly分类页面魔改</a><div class="blog-slider__text">butterfly分类页面魔改</div><a class="blog-slider__button" href="679887a0/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/939928.jpg" alt="https://cdn.keyiqingxin.cn/cover/939928.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-08-26</span><a class="blog-slider__title" href="df8718c1/">网格布局</a><div class="blog-slider__text">css 网格布局(grid)</div><a class="blog-slider__button" href="df8718c1/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/1111259.png" alt="https://cdn.keyiqingxin.cn/cover/1111259.png"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-08-02</span><a class="blog-slider__title" href="9b2de178/">vue2.x的api</a><div class="blog-slider__text">vue2.x的api</div><a class="blog-slider__button" href="9b2de178/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/1111254.jpg" alt="https://cdn.keyiqingxin.cn/cover/1111254.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-07-28</span><a class="blog-slider__title" href="262ac49e/">vue2.x进阶用法</a><div class="blog-slider__text">vue2.x的一些进阶用法</div><a class="blog-slider__button" href="262ac49e/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/670098.jpg" alt="https://cdn.keyiqingxin.cn/cover/670098.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-07-09</span><a class="blog-slider__title" href="c0add594/">vue2.x基本用法</a><div class="blog-slider__text">vue2.x基本用法</div><a class="blog-slider__button" href="c0add594/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/1111255.jpg" alt="https://cdn.keyiqingxin.cn/cover/1111255.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-07-01</span><a class="blog-slider__title" href="5650e2f5/">vercel托管node.js的api服务</a><div class="blog-slider__text">vercel托管node.js的api服务</div><a class="blog-slider__button" href="5650e2f5/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/942531.jpg" alt="https://cdn.keyiqingxin.cn/cover/942531.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-06-01</span><a class="blog-slider__title" href="317ea436/">bufferfly主题的应用和即时推送</a><div class="blog-slider__text">bufferfly主题的应用和即时推送</div><a class="blog-slider__button" href="317ea436/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/829919.png" alt="https://cdn.keyiqingxin.cn/cover/829919.png"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-06-01</span><a class="blog-slider__title" href="bf0e4745/">bufferfly主题的一些美化</a><div class="blog-slider__text">bufferfly 主题的一些美化</div><a class="blog-slider__button" href="bf0e4745/">🍡详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://cdn.keyiqingxin.cn/cover/820208.png" alt="https://cdn.keyiqingxin.cn/cover/820208.png"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-06-01</span><a class="blog-slider__title" href="f5fee1ca/">发布一个npm包</a><div class="blog-slider__text">发布一个npm包</div><a class="blog-slider__button" href="f5fee1ca/">🍡详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';console.log("已挂载swiper"),parent.insertAdjacentHTML("afterbegin",child)}</script><script data-pjax src="https://cdn.keyiqingxin.cn/zfswiper/swiper.min.js"></script><script data-pjax src="https://cdn.keyiqingxin.cn/zfswiper/swiperindex.js"></script><style></style><script data-pjax src="https://cdn.keyiqingxin.cn/js/github.js"></script><script data-pjax>function GithubCalendarConfig(){var t=document.getElementById("recent-posts");t&&"/"==location.pathname&&(console.log("已挂载github calendar"),t.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://python.keyiqingxin.cn/api?name=milkdue",["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"],"milkdue")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style></style><script data-pjax>function butterfly_footer_beautify_injector_config(){var e=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),e.insertAdjacentHTML("beforeend",'<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="主题采用butterfly" title=""><img src="https://cdn.keyiqingxin.cn/svg/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站已在工信部备案，备案号陕ICP备2023000684号-1" title=""><img src="https://cdn.keyiqingxin.cn/svg/bei.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20210025" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站已加入萌ICP豪华套餐，萌ICP备20210025号" title=""><img src="https://cdn.keyiqingxin.cn/svg/moe.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站使用腾讯云为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-腾讯云-blue?style=flat&amp;logo=icloud" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站默认线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站项目由Gtihub托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.keyiqingxin.cn/wow/wow.min.js"></script><script defer src="https://cdn.keyiqingxin.cn/wow/wow_init.js"></script><script defer src="https://cdn.keyiqingxin.cn/jquery/jquery.min.js"></script><script defer src="https://cdn.keyiqingxin.cn/kity/kity.min.js"></script><script defer src="https://cdn.keyiqingxin.cn/kityminder/kityminder.core.min.js"></script><script defer src="https://cdn.keyiqingxin.cn/tag_plugin/mindmap.js"></script><script async src="https://cdn.keyiqingxin.cn/js/font_2032782_8d5kxvn09md.js"></script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",(function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach((function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)}))}))</script><script>!function(t){t.imageLazyLoadSetting.processImages=o;var e=t.imageLazyLoadSetting.isSPA,n=t.imageLazyLoadSetting.preloadRatio||1,i=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(i=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var o,a=0;a<i.length;a++)0<=(o=(o=i[a]).getBoundingClientRect()).bottom&&0<=o.left&&o.top<=(t.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,o,r=i[a];t=r,e=function(){i=i.filter((function(t){return r!==t}))},n=new Image,o=t.getAttribute("data-original"),n.onload=function(){t.src=o,e&&e()},t.src!==o&&(n.src=o)}()}o(),t.addEventListener("scroll",(function(){var e,n;e=o,n=t,clearTimeout(e.tId),e.tId=setTimeout((function(){e.call(n)}),500)}))}(this)</script></body></html>